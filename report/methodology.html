<!DOCTYPE html>
<html lang="zh-Hant">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>AprNes - Testing Methodology</title>
<style>
*{box-sizing:border-box;margin:0;padding:0}
:root{
  --bg:#0f172a;--surface:#1e293b;--surface2:#283548;--border:#334155;
  --text:#e2e8f0;--text-dim:#94a3b8;
  --pass:#22c55e;--pass-bg:rgba(34,197,94,.15);
  --fail:#ef4444;--fail-bg:rgba(239,68,68,.15);
  --accent:#3b82f6;--accent2:#8b5cf6;
}
body{background:var(--bg);color:var(--text);font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',system-ui,sans-serif;line-height:1.6;padding:2rem;min-height:100vh;max-width:960px;margin:0 auto}
a{color:var(--accent);text-decoration:none}
a:hover{text-decoration:underline}
h1{font-size:1.8rem;margin-bottom:.25rem;letter-spacing:-.02em;text-align:center}
h2{font-size:1.2rem;margin:2rem 0 .75rem;padding-bottom:.4rem;border-bottom:1px solid var(--border);color:var(--accent)}
h3{font-size:.95rem;margin:1.2rem 0 .5rem;color:var(--text)}
p{margin-bottom:.75rem;font-size:.88rem;color:var(--text-dim)}
.back{display:inline-block;margin-bottom:1.5rem;font-size:.85rem}
.subtitle{text-align:center;color:var(--text-dim);font-size:.88rem;margin-bottom:2rem}

/* Overview cards */
.overview{display:grid;grid-template-columns:repeat(auto-fill,minmax(200px,1fr));gap:.85rem;margin:1.2rem 0 2rem}
.ov-card{background:var(--surface);border:1px solid var(--border);border-radius:8px;padding:1rem;text-align:center}
.ov-card .num{font-size:1.8rem;font-weight:700;color:var(--accent)}
.ov-card .lbl{font-size:.78rem;color:var(--text-dim);margin-top:.2rem}

/* Section cards */
.section{background:var(--surface);border:1px solid var(--border);border-radius:8px;padding:1.2rem 1.5rem;margin-bottom:1rem}
.section h3{margin-top:0;color:var(--accent);font-size:.95rem}
.section p{font-size:.82rem}
.section ul{margin:.5rem 0 .75rem 1.2rem;font-size:.82rem;color:var(--text-dim)}
.section li{margin-bottom:.3rem}

/* Code blocks */
code{background:var(--bg);padding:.15rem .4rem;border-radius:3px;font-size:.78rem;font-family:Consolas,Monaco,'Courier New',monospace}
pre{background:var(--bg);border:1px solid var(--border);border-radius:6px;padding:1rem;margin:.75rem 0;overflow-x:auto;font-size:.78rem;font-family:Consolas,Monaco,'Courier New',monospace;color:var(--text-dim);line-height:1.5}

/* Flow diagram */
.flow{display:flex;align-items:center;justify-content:center;gap:.5rem;flex-wrap:wrap;margin:1rem 0;font-size:.82rem}
.flow .step{background:var(--surface2);border:1px solid var(--border);border-radius:6px;padding:.5rem .8rem;text-align:center;min-width:100px}
.flow .step .title{font-weight:600;font-size:.78rem;color:var(--accent)}
.flow .step .desc{font-size:.7rem;color:var(--text-dim);margin-top:.2rem}
.flow .arrow{color:var(--text-dim);font-size:1.2rem}

/* Protocol table */
table{width:100%;border-collapse:collapse;margin:.75rem 0;font-size:.82rem}
th{background:var(--surface2);text-align:left;padding:.5rem .75rem;font-weight:600;font-size:.78rem;border:1px solid var(--border)}
td{padding:.45rem .75rem;border:1px solid var(--border);color:var(--text-dim)}
tr:hover td{background:var(--surface2)}

/* Suite coverage */
.suite-grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(280px,1fr));gap:.65rem;margin:.75rem 0}
.suite-item{display:flex;align-items:center;gap:.5rem;padding:.4rem .65rem;background:var(--surface);border:1px solid var(--border);border-radius:6px;font-size:.78rem}
.suite-item .count{font-weight:600;min-width:24px;text-align:center;font-size:.75rem;padding:.1rem .3rem;border-radius:4px}
.suite-item .count.c-blue{background:rgba(59,130,246,.15);color:var(--accent)}
.suite-item .name{color:var(--text-dim)}

.footer{text-align:center;color:var(--text-dim);font-size:.75rem;margin-top:2rem;padding-top:1rem;border-top:1px solid var(--border)}
</style>
</head>
<body>

<a href="index.html" class="back">&larr; Back to Test Report</a>
<h1>AprNes Testing Methodology</h1>
<p class="subtitle">NES emulator accuracy verification through hardware test ROMs</p>

<div class="overview">
  <div class="ov-card"><div class="num">174</div><div class="lbl">Test ROMs</div></div>
  <div class="ov-card"><div class="num">30+</div><div class="lbl">Test Suites</div></div>
  <div class="ov-card"><div class="num">5</div><div class="lbl">Subsystems</div></div>
  <div class="ov-card"><div class="num">&lt;3 min</div><div class="lbl">Full Run</div></div>
</div>

<!-- ───────────────── Section 1 ───────────────── -->
<h2>1. What We Test</h2>

<div class="section">
<p>AprNes uses <strong>hardware verification test ROMs</strong> originally written to validate real NES console behavior.
These are actual NES programs (6502 machine code) that exercise specific hardware features and report pass/fail.
The same ROMs are used by every major NES emulator project to measure accuracy.</p>

<p>Test coverage spans all major NES subsystems:</p>
<ul>
  <li><strong>CPU</strong> &mdash; All official 6502 instructions, addressing modes, timing, dummy reads/writes, interrupt behavior (NMI/IRQ/BRK interactions), branch timing, reset behavior</li>
  <li><strong>PPU</strong> &mdash; VBlank/NMI timing, sprite 0 hit, sprite overflow, open bus behavior, palette RAM, VRAM access, read buffer, even/odd frame toggle</li>
  <li><strong>APU</strong> &mdash; Frame counter timing (mode 0/1), length counter, IRQ flag timing, clock jitter, DMC rates, channel mixing, reset behavior</li>
  <li><strong>Mapper</strong> &mdash; MMC3 (Mapper 004) IRQ counter clocking, A12 detection, scanline timing, Rev A/B behavior</li>
  <li><strong>I/O</strong> &mdash; Controller reading accuracy, DPCM interference, DMA timing</li>
</ul>
</div>

<!-- ───────────────── Section 2 ───────────────── -->
<h2>2. Test ROM Sources</h2>

<div class="section">
<p>All ROMs come from the <strong>nes-test-roms</strong> collection, primarily authored by:</p>
<ul>
  <li><strong>blargg (Shay Green)</strong> &mdash; The most comprehensive NES test ROM author. His suites cover CPU instructions (v3/v5), APU timing, PPU VBL/NMI, sprite hit/overflow, and more. Two result protocols: legacy (screen-based) and modern ($6000 memory-mapped).</li>
  <li><strong>bisqwit</strong> &mdash; CPU timing tests</li>
  <li><strong>other community authors</strong> &mdash; MMC3 IRQ tests, DMA interaction tests, controller tests</li>
</ul>
<p>These are the same ROMs used by Mesen, Nestopia, FCEUX, and other reference emulators. Passing them indicates cycle-accurate or near-cycle-accurate emulation.</p>
</div>

<!-- ───────────────── Section 3 ───────────────── -->
<h2>3. Test Runner Architecture</h2>

<div class="flow">
  <div class="step"><div class="title">Bash Script</div><div class="desc">run_tests_report.sh</div></div>
  <span class="arrow">&rarr;</span>
  <div class="step"><div class="title">MSBuild</div><div class="desc">Compile emulator</div></div>
  <span class="arrow">&rarr;</span>
  <div class="step"><div class="title">Headless Emulator</div><div class="desc">TestRunner.cs</div></div>
  <span class="arrow">&rarr;</span>
  <div class="step"><div class="title">Result Detection</div><div class="desc">$6000 / Screen scan</div></div>
  <span class="arrow">&rarr;</span>
  <div class="step"><div class="title">Output</div><div class="desc">stdout / JSON / HTML</div></div>
</div>

<div class="section">
<h3>Headless Mode</h3>
<p>The emulator has a built-in <code>TestRunner.cs</code> that runs in headless mode &mdash; no window, no audio, no frame rate limiter. The CPU/PPU/APU all tick at maximum speed. A single test ROM typically completes in under 1 second.</p>

<h3>Two Scripts, Two Purposes</h3>
<p>The testing workflow uses two complementary scripts with identical test lists (174 ROMs):</p>
<ul>
  <li><strong><code>run_tests.sh</code></strong> &mdash; Lightweight validation script. Runs all tests and prints PASS/FAIL to stdout with a failure summary. Used for quick regression checks during development.</li>
  <li><strong><code>run_tests_report.sh</code></strong> &mdash; Full-featured report generator with modular output controlled by command-line flags.</li>
</ul>

<h3>Report Script Modes</h3>
<p><code>run_tests_report.sh</code> always prints PASS/FAIL results to stdout. Optional flags control additional outputs:</p>
<pre>bash run_tests_report.sh                        # Quick: stdout only
bash run_tests_report.sh --json                 # + save report/results.json
bash run_tests_report.sh --screenshots          # + capture screenshots (PNG&rarr;WebP)
bash run_tests_report.sh --json --screenshots   # Full: JSON + screenshots + HTML report
bash run_tests_report.sh --no-build             # Skip MSBuild compilation step</pre>

<p>The full pipeline (with all flags) performs:</p>
<ol style="margin:.5rem 0 .75rem 1.2rem;font-size:.82rem;color:var(--text-dim)">
  <li>Build the project with MSBuild (unless <code>--no-build</code>)</li>
  <li>Run each of 174 ROM files through the headless emulator</li>
  <li>Print PASS/FAIL to stdout for every test</li>
  <li>If <code>--screenshots</code>: capture the final frame as PNG, convert to lossless WebP</li>
  <li>If <code>--json</code>: collect results into <code>report/results.json</code></li>
  <li>If both <code>--json</code> and <code>--screenshots</code>: generate a single-file HTML report (<code>report/index.html</code>) with embedded data and screenshot references</li>
</ol>
</div>

<!-- ───────────────── Section 4 ───────────────── -->
<h2>4. Result Detection Mechanisms</h2>

<div class="section">
<h3>Mechanism A: $6000 Memory Protocol</h3>
<p>Modern blargg test ROMs use a memory-mapped status protocol. The test runner polls address <code>$6000</code> every frame:</p>

<table>
  <tr><th>$6000 Value</th><th>Meaning</th><th>Action</th></tr>
  <tr><td><code>$80</code></td><td>Test running</td><td>Continue waiting</td></tr>
  <tr><td><code>$81</code></td><td>Reset requested</td><td>Wait 100ms, then soft reset</td></tr>
  <tr><td><code>$00</code></td><td>Test passed</td><td>Exit with code 0</td></tr>
  <tr><td><code>$01-$7F</code></td><td>Test failed (error code N)</td><td>Exit with code N</td></tr>
</table>

<p>Result text is read from <code>$6004+</code> as null-terminated ASCII. This gives detailed error messages like "Flag first set too late" or "Length counter not clocked correctly".</p>

<h3>Mechanism B: Screen Stability Detection</h3>
<p>Older blargg tests (2005 era) don't use the $6000 protocol. They render results directly to the PPU nametable. The test runner handles these with a multi-step heuristic:</p>
<ol style="margin:.5rem 0 .75rem 1.2rem;font-size:.82rem;color:var(--text-dim)">
  <li>After 120 frames (~2 sec), start sampling the screen buffer every frame</li>
  <li>Compute a hash of the framebuffer (sampling every 37th pixel for speed)</li>
  <li>When the hash stays identical for 90 consecutive frames (~1.5 sec), the screen is "stable"</li>
  <li>Scan the PPU nametable (character map) for known result strings:
    <ul>
      <li><code>"Passed"</code> / <code>"PASSED"</code> &rarr; PASS</li>
      <li><code>"Failed"</code> / <code>"FAILED"</code> &rarr; FAIL</li>
      <li><code>"$01"</code> (hex on screen) &rarr; PASS</li>
      <li><code>"$02"</code> ~ <code>"$FF"</code> (hex on screen) &rarr; FAIL</li>
      <li><code>"All tests complete"</code> &rarr; PASS</li>
      <li><code>" 0/"</code> (zero error count) &rarr; PASS</li>
    </ul>
  </li>
</ol>
<p>This approach reads the PPU nametable directly (not OCR on pixels), making it fast and reliable.</p>
</div>

<!-- ───────────────── Section 5 ───────────────── -->
<h2>5. Automation Features</h2>

<div class="section">
<h3>Auto Soft Reset</h3>
<p>Some test ROMs write <code>$81</code> to <code>$6000</code> to request a console reset (testing power-on/reset behavior). The runner detects this and automatically performs a soft reset after a 100ms delay, mimicking a human pressing the reset button. Supports up to 10 sequential resets per ROM.</p>

<h3>Simulated Controller Input</h3>
<p>Controller read tests need actual button presses. The <code>--input</code> parameter schedules timed button events:</p>
<pre>--input "A:2.0,B:4.0,Select:6.0,Start:8.0,Up:10.0,Down:12.0,Left:14.0,Right:16.0"</pre>
<p>Each button is pressed at the specified time (seconds) and held for 10 frames (~166ms). This lets tests like <code>read_joy3/test_buttons</code> verify that all 8 buttons are correctly detected in sequence.</p>

<h3>Screenshot Capture (optional)</h3>
<p>When enabled with <code>--screenshots</code>, the final frame of each test is captured as a 256x240 PNG, then converted to lossless WebP (typically 60-80% smaller). Screenshots serve as visual evidence &mdash; many test ROMs display their results on screen as text, showing exactly what passed or failed. For quick regression checks, screenshots can be skipped to save time.</p>

<h3>Timeout Safety</h3>
<p>Each ROM has a configurable <code>--max-wait</code> timeout (default 30 seconds, 120 for merged/multi-sub-test ROMs). If a test ROM enters an infinite loop or hangs, the runner terminates it gracefully and reports the last known state.</p>
</div>

<!-- ───────────────── Section 6 ───────────────── -->
<h2>6. Test Suite Coverage</h2>

<div class="suite-grid">
  <div class="suite-item"><span class="count c-blue">4</span><span class="name">apu_mixer &mdash; Channel mixing</span></div>
  <div class="suite-item"><span class="count c-blue">6</span><span class="name">apu_reset &mdash; APU power/reset</span></div>
  <div class="suite-item"><span class="count c-blue">9</span><span class="name">apu_test &mdash; APU frame counter</span></div>
  <div class="suite-item"><span class="count c-blue">11</span><span class="name">blargg_apu_2005 &mdash; APU timing</span></div>
  <div class="suite-item"><span class="count c-blue">2</span><span class="name">blargg_cpu_test5 &mdash; CPU instructions</span></div>
  <div class="suite-item"><span class="count c-blue">5</span><span class="name">blargg_ppu_tests &mdash; PPU basics</span></div>
  <div class="suite-item"><span class="count c-blue">3</span><span class="name">branch_timing &mdash; Branch cycle count</span></div>
  <div class="suite-item"><span class="count c-blue">1</span><span class="name">cpu_dummy_reads &mdash; Dummy read cycles</span></div>
  <div class="suite-item"><span class="count c-blue">2</span><span class="name">cpu_dummy_writes &mdash; Dummy write cycles</span></div>
  <div class="suite-item"><span class="count c-blue">2</span><span class="name">cpu_exec_space &mdash; Execution from I/O</span></div>
  <div class="suite-item"><span class="count c-blue">6</span><span class="name">cpu_interrupts_v2 &mdash; NMI/IRQ interaction</span></div>
  <div class="suite-item"><span class="count c-blue">2</span><span class="name">cpu_reset &mdash; CPU reset behavior</span></div>
  <div class="suite-item"><span class="count c-blue">1</span><span class="name">cpu_timing_test6 &mdash; Instruction timing</span></div>
  <div class="suite-item"><span class="count c-blue">5</span><span class="name">dmc_dma_during_read &mdash; DMC DMA conflicts</span></div>
  <div class="suite-item"><span class="count c-blue">5</span><span class="name">instr_misc &mdash; Misc instruction tests</span></div>
  <div class="suite-item"><span class="count c-blue">17</span><span class="name">instr_test-v3 &mdash; All 6502 instructions</span></div>
  <div class="suite-item"><span class="count c-blue">18</span><span class="name">instr_test-v5 &mdash; All 6502 instructions (v5)</span></div>
  <div class="suite-item"><span class="count c-blue">3</span><span class="name">instr_timing &mdash; Instruction cycle timing</span></div>
  <div class="suite-item"><span class="count c-blue">6</span><span class="name">mmc3_irq_tests &mdash; MMC3 IRQ counter</span></div>
  <div class="suite-item"><span class="count c-blue">6</span><span class="name">mmc3_test &mdash; MMC3 behavior</span></div>
  <div class="suite-item"><span class="count c-blue">6</span><span class="name">mmc3_test_2 &mdash; MMC3 behavior (v2)</span></div>
  <div class="suite-item"><span class="count c-blue">11</span><span class="name">nes_instr_test &mdash; CPU instructions (alt)</span></div>
  <div class="suite-item"><span class="count c-blue">1</span><span class="name">oam_read &mdash; OAM read behavior</span></div>
  <div class="suite-item"><span class="count c-blue">1</span><span class="name">ppu_open_bus &mdash; PPU open bus</span></div>
  <div class="suite-item"><span class="count c-blue">1</span><span class="name">ppu_read_buffer &mdash; PPU read buffer</span></div>
  <div class="suite-item"><span class="count c-blue">11</span><span class="name">ppu_vbl_nmi &mdash; VBlank/NMI timing</span></div>
  <div class="suite-item"><span class="count c-blue">4</span><span class="name">read_joy3 &mdash; Controller reading</span></div>
  <div class="suite-item"><span class="count c-blue">2</span><span class="name">sprdma_and_dmc_dma &mdash; DMA conflicts</span></div>
  <div class="suite-item"><span class="count c-blue">11</span><span class="name">sprite_hit_tests &mdash; Sprite 0 hit</span></div>
  <div class="suite-item"><span class="count c-blue">5</span><span class="name">sprite_overflow &mdash; Sprite overflow</span></div>
  <div class="suite-item"><span class="count c-blue">7</span><span class="name">vbl_nmi_timing &mdash; VBL/NMI timing</span></div>
</div>

<!-- ───────────────── Section 7 ───────────────── -->
<h2>7. Command-Line Interface</h2>

<div class="section">
<p>The headless test runner is invoked directly via the emulator executable:</p>
<pre>AprNes.exe --rom &lt;file.nes&gt; [options]</pre>

<table>
  <tr><th>Option</th><th>Description</th></tr>
  <tr><td><code>--rom &lt;path&gt;</code></td><td>ROM file to load (required)</td></tr>
  <tr><td><code>--wait-result</code></td><td>Monitor $6000 / screen for test result</td></tr>
  <tr><td><code>--max-wait &lt;sec&gt;</code></td><td>Timeout in seconds (default: 30)</td></tr>
  <tr><td><code>--time &lt;sec&gt;</code></td><td>Run for exactly N seconds, then stop</td></tr>
  <tr><td><code>--screenshot &lt;path&gt;</code></td><td>Save final frame as PNG</td></tr>
  <tr><td><code>--log &lt;path&gt;</code></td><td>Write result line to file</td></tr>
  <tr><td><code>--soft-reset &lt;sec&gt;</code></td><td>Trigger soft reset at N seconds</td></tr>
  <tr><td><code>--input &lt;spec&gt;</code></td><td>Schedule button presses (e.g. "A:2.0,B:4.0")</td></tr>
  <tr><td><code>--debug-log &lt;path&gt;</code></td><td>Write CPU trace log</td></tr>
</table>

<p>Exit codes: <code>0</code> = pass, <code>1-127</code> = fail (test error code), <code>255</code> = timeout/no result.</p>
</div>

<!-- ───────────────── Section 8 ───────────────── -->
<h2>8. Emulator Design Requirements for QA Integration</h2>

<p>To adopt this automated QA workflow, an emulator must expose a set of design interfaces. Below is a reference based on AprNes's architecture &mdash; the pattern is applicable to any NES emulator regardless of language.</p>

<div class="section">
<h3>8.1 Dual Entry Point: GUI vs Headless</h3>
<p>The emulator should support two modes of operation from a single executable. When command-line arguments are present, it enters headless test mode; otherwise it launches the normal GUI.</p>
<pre>// Program.cs — entry point
static int Main(string[] args)
{
    if (args.Length > 0)
        return TestRunner.Run(args);    // headless mode, returns exit code

    Application.Run(new MainForm());    // normal GUI mode
    return 0;
}</pre>
<p>Key point: <code>Main()</code> returns <code>int</code> (not <code>void</code>) so the exit code can signal pass/fail to the calling script.</p>
</div>

<div class="section">
<h3>8.2 Headless Mode Flags</h3>
<p>The emulator core needs static flags to suppress GUI and audio subsystems when running in test mode:</p>

<table>
  <tr><th>Flag</th><th>Purpose</th><th>Effect</th></tr>
  <tr><td><code>HeadlessMode = true</code></td><td>Suppress window creation</td><td>No Form/Window is instantiated; rendering still runs to fill the framebuffer, but no display output occurs</td></tr>
  <tr><td><code>AudioEnabled = false</code></td><td>Suppress audio output</td><td>APU still ticks (needed for timing tests), but no audio device is opened</td></tr>
  <tr><td><code>LimitFPS = false</code></td><td>Remove frame rate limiter</td><td>Emulation runs at maximum CPU speed; a 30-second test completes in &lt;1 second wall time</td></tr>
  <tr><td><code>exit = true</code></td><td>Signal the main loop to stop</td><td>Set by the test runner when a result is detected; the <code>run()</code> loop checks this flag each frame</td></tr>
</table>

<p>These flags allow the CPU/PPU/APU to continue ticking normally &mdash; only the I/O endpoints (display, speakers) are disabled. This ensures that timing-sensitive tests produce identical results in headless and GUI modes.</p>
</div>

<div class="section">
<h3>8.3 Per-Frame Callback (VideoOutput Event)</h3>
<p>The emulator must provide a per-frame hook that fires after each frame is fully rendered. The test runner subscribes to this event to poll for results:</p>
<pre>// In NesCore (emulator core):
public static event EventHandler VideoOutput;

// Fired at the end of each PPU frame (scanline 240, after VBlank begins):
VideoOutput?.Invoke(null, null);

// In TestRunner:
NesCore.VideoOutput += (sender, e) => {
    frameCount++;
    byte status = NesCore.NES_MEM[0x6000];  // poll test protocol
    // ... detect result, set NesCore.exit = true when done
};</pre>
<p>This callback-driven design avoids tight polling loops and integrates cleanly with both GUI (refresh display) and headless (check test status) modes.</p>
</div>

<div class="section">
<h3>8.4 Memory and PPU RAM Access</h3>
<p>The test runner needs direct read access to two memory regions:</p>

<table>
  <tr><th>Memory Region</th><th>Access Pattern</th><th>Purpose</th></tr>
  <tr><td><code>NES_MEM[0x6000..0x6FFF]</code></td><td>CPU address space (WRAM)</td><td>Read $6000 status byte and $6004+ result text (blargg protocol)</td></tr>
  <tr><td><code>ppu_ram[0x2000..0x23BF]</code></td><td>PPU nametable 0</td><td>Scan for "Passed"/"Failed" text on screen (older test ROMs)</td></tr>
  <tr><td><code>ScreenBuf1x[0..61439]</code></td><td>Rendered framebuffer (256x240 ARGB)</td><td>Screen stability hash + screenshot capture</td></tr>
</table>

<p>These must be exposed as static pointers or arrays &mdash; no copying per frame. The test runner reads them synchronously inside the <code>VideoOutput</code> callback, so thread safety is guaranteed by the frame boundary.</p>
</div>

<div class="section">
<h3>8.5 Soft Reset API</h3>
<p>Some test ROMs request a console reset by writing <code>$81</code> to <code>$6000</code>. The emulator must expose a <code>SoftReset()</code> method that resets CPU/APU state without reloading the ROM:</p>
<pre>public static void SoftReset()
{
    // Reset CPU: read reset vector from $FFFC/$FFFD, clear registers
    // Reset APU: reinitialize frame counter, silence channels
    // Do NOT reset PPU fully (some tests depend on PPU state surviving reset)
    // Do NOT unload the ROM or reinitialize mapper
}</pre>
<p>This is distinct from a hard reset (power cycle). The test runner calls <code>SoftReset()</code> after a 100ms delay (~6 frames) when it detects <code>$6000 == $81</code>.</p>
</div>

<div class="section">
<h3>8.6 Controller Input Injection</h3>
<p>Controller tests need programmatic button presses. The emulator must expose button press/release methods:</p>
<pre>public static void P1_ButtonPress(byte buttonIndex);   // 0=A,1=B,2=Sel,3=Start,4=Up,5=Down,6=Left,7=Right
public static void P1_ButtonUnPress(byte buttonIndex);</pre>
<p>The test runner schedules events by frame number. Each button is pressed at the specified frame and released after a configurable hold duration (default 10 frames &asymp; 166ms).</p>
</div>

<div class="section">
<h3>8.7 ROM Loading API</h3>
<p>The emulator needs a simple byte-array-based ROM loading interface:</p>
<pre>public static bool init(byte[] rom_bytes);  // parse iNES header, set up mapper, reset CPU
public static void run();                    // main emulation loop (blocks until exit==true)</pre>
<p><code>init()</code> returns <code>false</code> for unsupported mappers or corrupt headers. <code>run()</code> is called on a background thread by the test runner, which waits for completion via <code>Thread.Join()</code>.</p>
</div>

<div class="section">
<h3>8.8 Architecture Summary</h3>

<div class="flow">
  <div class="step"><div class="title">Program.cs</div><div class="desc">Entry point<br>GUI / Headless fork</div></div>
  <span class="arrow">&rarr;</span>
  <div class="step"><div class="title">TestRunner.cs</div><div class="desc">Argument parsing<br>Frame callback<br>Result detection</div></div>
  <span class="arrow">&rarr;</span>
  <div class="step"><div class="title">NesCore</div><div class="desc">init() / run()<br>HeadlessMode flags<br>VideoOutput event</div></div>
</div>

<p>The design principle is <strong>minimal coupling</strong>: the test runner interacts with the emulator core through 8 touch points (3 flags, 1 event, 3 memory regions, 1 reset method). The emulator core requires zero knowledge of the test runner &mdash; it simply checks <code>HeadlessMode</code> to skip GUI creation and fires <code>VideoOutput</code> each frame. All test logic lives in <code>TestRunner.cs</code>.</p>

<table>
  <tr><th>Interface</th><th>Direction</th><th>Type</th></tr>
  <tr><td><code>HeadlessMode</code></td><td>TestRunner &rarr; Core</td><td>Static bool flag</td></tr>
  <tr><td><code>AudioEnabled</code></td><td>TestRunner &rarr; Core</td><td>Static bool flag</td></tr>
  <tr><td><code>LimitFPS</code></td><td>TestRunner &rarr; Core</td><td>Static bool flag</td></tr>
  <tr><td><code>exit</code></td><td>TestRunner &rarr; Core</td><td>Static bool flag</td></tr>
  <tr><td><code>VideoOutput</code></td><td>Core &rarr; TestRunner</td><td>Event (per-frame callback)</td></tr>
  <tr><td><code>NES_MEM / ppu_ram / ScreenBuf1x</code></td><td>Core &rarr; TestRunner</td><td>Static memory pointers (read-only)</td></tr>
  <tr><td><code>SoftReset()</code></td><td>TestRunner &rarr; Core</td><td>Static method</td></tr>
  <tr><td><code>P1_ButtonPress/UnPress()</code></td><td>TestRunner &rarr; Core</td><td>Static methods</td></tr>
  <tr><td><code>init(byte[]) / run()</code></td><td>TestRunner &rarr; Core</td><td>Static methods</td></tr>
</table>

<p>This architecture makes the QA system <strong>portable</strong>: any NES emulator that exposes these interfaces can use the same bash scripts and test ROM collection for automated regression testing, regardless of its internal implementation.</p>
</div>

<h2>9. AI-Assisted Development Workflow with Claude Code</h2>

<div class="section">
<h3>9.1 Overview</h3>
<p>AprNes uses <a href="https://docs.anthropic.com/en/docs/claude-code">Claude Code</a> (Anthropic's CLI agent) as an AI pair-programmer that directly invokes the test shell scripts, reads failure output, diagnoses root causes, edits source code, and verifies fixes — all within a single iterative loop. The test infrastructure described in Sections 1-8 is the foundation that makes this workflow possible.</p>

<div class="flow">
  <div class="step"><div class="title">TODO.md</div><div class="desc">Pick next bug</div></div>
  <div class="arrow">&rarr;</div>
  <div class="step"><div class="title">Analyse</div><div class="desc">Run failing tests<br>Read test ROM source</div></div>
  <div class="arrow">&rarr;</div>
  <div class="step"><div class="title">Plan</div><div class="desc">Root cause + fix design</div></div>
  <div class="arrow">&rarr;</div>
  <div class="step"><div class="title">Implement</div><div class="desc">Edit emulator code</div></div>
  <div class="arrow">&rarr;</div>
  <div class="step"><div class="title">Verify</div><div class="desc">Build &amp; run tests</div></div>
  <div class="arrow">&rarr;</div>
  <div class="step"><div class="title">Document</div><div class="desc">bugfix/ + TODO.md<br>git commit &amp; push</div></div>
</div>
</div>

<div class="section">
<h3>9.2 Prerequisites</h3>
<ul>
  <li><strong>Claude Code CLI</strong> — installed and authenticated (<code>npm install -g @anthropic-ai/claude-code</code>)</li>
  <li><strong>Project memory</strong> — <code>.claude/</code> directory with <code>MEMORY.md</code> recording architecture, build commands, and conventions so the agent retains context across sessions</li>
  <li><strong>Test scripts</strong> — <code>run_tests.sh</code> (quick validation) and <code>run_tests_report.sh</code> (full report with JSON/screenshots) on PATH</li>
  <li><strong>Test ROMs</strong> — <code>nes-test-roms-master/checked/</code> containing all test suites</li>
  <li><strong>TODO.md</strong> — prioritised bug list with failure details, serving as the task queue</li>
</ul>
</div>

<div class="section">
<h3>9.3 Step-by-Step Workflow</h3>

<h3>Phase 1: Task Selection</h3>
<p>The developer tells Claude Code to read <code>TODO.md</code> and continue with the next task. Claude picks the highest-priority unfinished bug and identifies the relevant failing tests.</p>
<pre>User: 閱讀 TODO.MD，繼續後面任務
Claude: [reads TODO.md, identifies "Bug G — Sprite timing" as next target]
        [runs 4 failing tests with --screenshots to capture current state]</pre>

<h3>Phase 2: Root Cause Analysis</h3>
<p>Claude uses the test infrastructure to diagnose the bug:</p>
<ul>
  <li><strong>Run failing test ROMs</strong> individually via the headless CLI, capturing exit codes and screen output</li>
  <li><strong>Read test ROM assembly source</strong> to understand exactly what the test expects (cycle counts, flag timing, etc.)</li>
  <li><strong>Read emulator source code</strong> (PPU.cs, CPU.cs, APU.cs, etc.) to find the discrepancy</li>
  <li><strong>Cross-reference</strong> NES hardware documentation (nesdev wiki) with the emulator implementation</li>
</ul>
<pre># Claude runs each failing test to see the exact failure message
./AprNes/bin/Debug/AprNes.exe --wait-result --max-wait 30 \
  --rom nes-test-roms-master/checked/sprite_hit_tests_2005.10.05/09.timing_basics.nes
# → FAIL #3: "upper-left corner too late"</pre>

<h3>Phase 3: Plan Mode</h3>
<p>For non-trivial fixes, Claude enters <strong>plan mode</strong> — a read-only state where it designs the implementation strategy without modifying any files. The plan includes:</p>
<ul>
  <li>Root cause explanation with hardware timing details</li>
  <li>Specific code changes with line-level locations</li>
  <li>Regression risk analysis (which existing PASS tests might break)</li>
  <li>Verification commands to run after implementation</li>
</ul>
<p>The developer reviews and approves the plan before any code is changed.</p>

<h3>Phase 4: Implementation</h3>
<p>Claude edits the emulator source files using precise text replacements. Each change is targeted and minimal — only modifying what the plan specified.</p>

<h3>Phase 5: Build &amp; Verify</h3>
<p>Claude invokes the build toolchain and test scripts directly:</p>
<pre># 1. Build
powershell -NoProfile -Command "MSBuild.exe AprNes.sln /p:Configuration=Debug /t:Rebuild"

# 2. Run target tests (the ones we're trying to fix)
./AprNes/bin/Debug/AprNes.exe --wait-result --max-wait 30 \
  --rom nes-test-roms-master/checked/sprite_hit_tests_2005.10.05/09.timing_basics.nes

# 3. Run regression suite (related tests that might break)
for rom in 01.basics.nes 02.alignment.nes ... 11.edge_timing.nes; do
  ./AprNes/bin/Debug/AprNes.exe --wait-result --max-wait 30 \
    --rom "nes-test-roms-master/checked/sprite_hit_tests_2005.10.05/$rom"
done

# 4. Full regression (all 174 tests)
bash run_tests.sh</pre>
<p>If any test fails unexpectedly, Claude reads the failure output, adjusts the fix, and re-runs. This inner loop repeats until all target tests pass with zero regressions.</p>

<h3>Phase 6: Documentation &amp; Commit</h3>
<p>Once verified, Claude:</p>
<ul>
  <li>Updates <code>TODO.md</code> — marks the bug as completed, updates the baseline count</li>
  <li>Creates <code>bugfix/YYYY-MM-DD_BUGFIXNN.md</code> — detailed record of problem, root cause, fix, and test results</li>
  <li>Commits with a descriptive message: <code>fix sprite timing: per-pixel hit + cycle-accurate overflow: 165 PASS / 9 FAIL (+4)</code></li>
  <li>Pushes to remote</li>
</ul>

<h3>Phase 7: Report Generation (on demand)</h3>
<p>The developer can request a full HTML report at any time:</p>
<pre>bash run_tests_report.sh --json --screenshots
# → report/index.html (interactive dashboard with screenshots)</pre>
</div>

<div class="section">
<h3>9.4 Key Files in the Workflow</h3>

<table>
  <tr><th>File</th><th>Role</th></tr>
  <tr><td><code>TODO.md</code></td><td>Prioritised bug list — the task queue that drives each session</td></tr>
  <tr><td><code>.claude/memory/MEMORY.md</code></td><td>Persistent agent memory: architecture, build commands, conventions</td></tr>
  <tr><td><code>bugfix/YYYY-MM-DD_BUGFIXNN.md</code></td><td>Per-fix documentation: problem, root cause, changes, verification</td></tr>
  <tr><td><code>run_tests.sh</code></td><td>Quick validation — runs all 174 tests, outputs PASS/FAIL counts</td></tr>
  <tr><td><code>run_tests_report.sh</code></td><td>Full report — JSON data + screenshots + HTML dashboard</td></tr>
  <tr><td><code>report/index.html</code></td><td>Generated interactive test report with filterable results</td></tr>
</table>
</div>

<div class="section">
<h3>9.5 Why This Works</h3>
<ul>
  <li><strong>Deterministic feedback</strong> — Test ROMs produce binary PASS/FAIL with exact failure descriptions (e.g. "upper-left corner too late"), giving the AI precise signals to work with</li>
  <li><strong>Headless CLI</strong> — The emulator's <code>--wait-result</code> mode returns machine-readable exit codes (0=pass, 1=fail), enabling automated verification loops</li>
  <li><strong>Structured knowledge</strong> — <code>TODO.md</code> provides prioritised task context; <code>MEMORY.md</code> carries architectural knowledge across sessions; <code>bugfix/</code> records capture the reasoning behind each change</li>
  <li><strong>Fast iteration</strong> — Build + single test takes ~5 seconds; full 174-test regression under 10 minutes. The AI can try multiple approaches in one session</li>
  <li><strong>Human oversight</strong> — Plan mode ensures the developer reviews the approach before any code changes. Git commits are explicit checkpoints</li>
</ul>
</div>

<div class="section">
<h3>9.6 Example Session: BUGFIX17 (Sprite Timing)</h3>
<p>A single Claude Code session progressed from 161 PASS → 165 PASS (+4) by:</p>
<ol style="margin:.5rem 0 .75rem 1.2rem;font-size:.82rem;color:var(--text-dim)">
  <li>Reading <code>TODO.md</code> → identified Bug G (4 failing sprite tests)</li>
  <li>Running each failing test → captured exact failure messages (#3 "too late", #5 "set too late", #2 "byte offset bug")</li>
  <li>Reading test ROM assembly source (09.timing_basics.asm, 3.Timing.a, 4.Obscure.a) → understood expected cycle counts</li>
  <li>Reading PPU.cs → found batch rendering at phase 7 (7-dot latency) and cycle-257 overflow detection</li>
  <li>Entered plan mode → designed 3 fixes: per-pixel hit detection, cycle-accurate overflow, hardware overflow bug</li>
  <li>Implemented all 3 fixes in PPU.cs (~+120 lines, -40 lines)</li>
  <li>Built → ran 4 target tests (all PASS) → ran sprite regression (14 tests, all PASS) → ran full suite (165 PASS / 9 FAIL)</li>
  <li>Updated TODO.md, created BUGFIX17.md, committed and pushed</li>
</ol>
<p>Total: 3 root causes identified, 3 fixes implemented, 0 regressions — all within a single conversation.</p>
</div>

<div class="footer"><a href="index.html">Test Report</a> | AprNes Testing Methodology</div>

</body>
</html>
