<!DOCTYPE html>
<html lang="zh-Hant">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>AprNes - 測試方法論</title>
<style>
*{box-sizing:border-box;margin:0;padding:0}
:root{
  --bg:#0f172a;--surface:#1e293b;--surface2:#283548;--border:#334155;
  --text:#e2e8f0;--text-dim:#94a3b8;
  --pass:#22c55e;--pass-bg:rgba(34,197,94,.15);
  --fail:#ef4444;--fail-bg:rgba(239,68,68,.15);
  --accent:#3b82f6;--accent2:#8b5cf6;
}
body{background:var(--bg);color:var(--text);font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',system-ui,sans-serif;line-height:1.6;padding:2rem;min-height:100vh;max-width:960px;margin:0 auto}
a{color:var(--accent);text-decoration:none}
a:hover{text-decoration:underline}
h1{font-size:1.8rem;margin-bottom:.25rem;letter-spacing:-.02em;text-align:center}
h2{font-size:1.2rem;margin:2rem 0 .75rem;padding-bottom:.4rem;border-bottom:1px solid var(--border);color:var(--accent)}
h3{font-size:.95rem;margin:1.2rem 0 .5rem;color:var(--text)}
p{margin-bottom:.75rem;font-size:.88rem;color:var(--text-dim)}
.back{display:inline-block;margin-bottom:1.5rem;font-size:.85rem}
.subtitle{text-align:center;color:var(--text-dim);font-size:.88rem;margin-bottom:2rem}

/* Overview cards */
.overview{display:grid;grid-template-columns:repeat(auto-fill,minmax(200px,1fr));gap:.85rem;margin:1.2rem 0 2rem}
.ov-card{background:var(--surface);border:1px solid var(--border);border-radius:8px;padding:1rem;text-align:center}
.ov-card .num{font-size:1.8rem;font-weight:700;color:var(--accent)}
.ov-card .lbl{font-size:.78rem;color:var(--text-dim);margin-top:.2rem}

/* Section cards */
.section{background:var(--surface);border:1px solid var(--border);border-radius:8px;padding:1.2rem 1.5rem;margin-bottom:1rem}
.section h3{margin-top:0;color:var(--accent);font-size:.95rem}
.section p{font-size:.82rem}
.section ul{margin:.5rem 0 .75rem 1.2rem;font-size:.82rem;color:var(--text-dim)}
.section li{margin-bottom:.3rem}

/* Code blocks */
code{background:var(--bg);padding:.15rem .4rem;border-radius:3px;font-size:.78rem;font-family:Consolas,Monaco,'Courier New',monospace}
pre{background:var(--bg);border:1px solid var(--border);border-radius:6px;padding:1rem;margin:.75rem 0;overflow-x:auto;font-size:.78rem;font-family:Consolas,Monaco,'Courier New',monospace;color:var(--text-dim);line-height:1.5}

/* Flow diagram */
.flow{display:flex;align-items:center;justify-content:center;gap:.5rem;flex-wrap:wrap;margin:1rem 0;font-size:.82rem}
.flow .step{background:var(--surface2);border:1px solid var(--border);border-radius:6px;padding:.5rem .8rem;text-align:center;min-width:100px}
.flow .step .title{font-weight:600;font-size:.78rem;color:var(--accent)}
.flow .step .desc{font-size:.7rem;color:var(--text-dim);margin-top:.2rem}
.flow .arrow{color:var(--text-dim);font-size:1.2rem}

/* Protocol table */
table{width:100%;border-collapse:collapse;margin:.75rem 0;font-size:.82rem}
th{background:var(--surface2);text-align:left;padding:.5rem .75rem;font-weight:600;font-size:.78rem;border:1px solid var(--border)}
td{padding:.45rem .75rem;border:1px solid var(--border);color:var(--text-dim)}
tr:hover td{background:var(--surface2)}

/* Suite coverage */
.suite-grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(280px,1fr));gap:.65rem;margin:.75rem 0}
.suite-item{display:flex;align-items:center;gap:.5rem;padding:.4rem .65rem;background:var(--surface);border:1px solid var(--border);border-radius:6px;font-size:.78rem}
.suite-item .count{font-weight:600;min-width:24px;text-align:center;font-size:.75rem;padding:.1rem .3rem;border-radius:4px}
.suite-item .count.c-blue{background:rgba(59,130,246,.15);color:var(--accent)}
.suite-item .name{color:var(--text-dim)}

.footer{text-align:center;color:var(--text-dim);font-size:.75rem;margin-top:2rem;padding-top:1rem;border-top:1px solid var(--border)}
</style>
</head>
<body>

<a href="index.html" class="back">&larr; 返回測試報告</a>
<h1>AprNes 測試方法論</h1>
<p class="subtitle">透過硬體測試 ROM 驗證 NES 模擬器精確度</p>

<div class="overview">
  <div class="ov-card"><div class="num">174</div><div class="lbl">測試 ROM</div></div>
  <div class="ov-card"><div class="num">30+</div><div class="lbl">測試套件</div></div>
  <div class="ov-card"><div class="num">5</div><div class="lbl">子系統</div></div>
  <div class="ov-card"><div class="num">&lt;3 分鐘</div><div class="lbl">完整執行</div></div>
</div>

<!-- ───────────────── 第 1 節 ───────────────── -->
<h2>1. 測試內容</h2>

<div class="section">
<p>AprNes 使用<strong>硬體驗證測試 ROM</strong>，這些 ROM 最初是為了驗證真實 NES 主機行為而編寫的。
它們是實際的 NES 程式（6502 機器碼），用於測試特定硬體功能並回報通過/失敗結果。
所有主流 NES 模擬器專案都使用相同的 ROM 來衡量精確度。</p>

<p>測試涵蓋所有主要 NES 子系統：</p>
<ul>
  <li><strong>CPU</strong> &mdash; 所有官方 6502 指令、定址模式、時序、虛擬讀取/寫入、中斷行為（NMI/IRQ/BRK 互動）、分支時序、重設行為</li>
  <li><strong>PPU</strong> &mdash; VBlank/NMI 時序、精靈 0 命中、精靈溢位、開放匯流排行為、調色盤 RAM、VRAM 存取、讀取緩衝區、奇偶影格切換</li>
  <li><strong>APU</strong> &mdash; 影格計數器時序（模式 0/1）、長度計數器、IRQ 旗標時序、時脈抖動、DMC 速率、聲道混音、重設行為</li>
  <li><strong>Mapper</strong> &mdash; MMC3（Mapper 004）IRQ 計數器時脈、A12 偵測、掃描線時序、Rev A/B 行為</li>
  <li><strong>I/O</strong> &mdash; 控制器讀取精確度、DPCM 干擾、DMA 時序</li>
</ul>
</div>

<!-- ───────────────── 第 2 節 ───────────────── -->
<h2>2. 測試 ROM 來源</h2>

<div class="section">
<p>所有 ROM 來自 <strong>nes-test-roms</strong> 合集，主要作者包括：</p>
<ul>
  <li><strong>blargg (Shay Green)</strong> &mdash; 最全面的 NES 測試 ROM 作者。他的套件涵蓋 CPU 指令（v3/v5）、APU 時序、PPU VBL/NMI、精靈命中/溢位等。兩種結果協定：傳統型（畫面偵測）與現代型（$6000 記憶體映射）。</li>
  <li><strong>bisqwit</strong> &mdash; CPU 時序測試</li>
  <li><strong>其他社群作者</strong> &mdash; MMC3 IRQ 測試、DMA 互動測試、控制器測試</li>
</ul>
<p>這些 ROM 與 Mesen、Nestopia、FCEUX 及其他參考模擬器使用的完全相同。通過這些測試代表模擬已達到週期精確或接近週期精確的程度。</p>
</div>

<!-- ───────────────── 第 3 節 ───────────────── -->
<h2>3. 測試執行器架構</h2>

<div class="flow">
  <div class="step"><div class="title">Bash 腳本</div><div class="desc">run_tests_report.sh</div></div>
  <span class="arrow">&rarr;</span>
  <div class="step"><div class="title">MSBuild</div><div class="desc">編譯模擬器</div></div>
  <span class="arrow">&rarr;</span>
  <div class="step"><div class="title">無頭模擬器</div><div class="desc">TestRunner.cs</div></div>
  <span class="arrow">&rarr;</span>
  <div class="step"><div class="title">結果偵測</div><div class="desc">$6000 / 畫面掃描</div></div>
  <span class="arrow">&rarr;</span>
  <div class="step"><div class="title">輸出</div><div class="desc">stdout / JSON / HTML</div></div>
</div>

<div class="section">
<h3>無頭模式</h3>
<p>模擬器內建 <code>TestRunner.cs</code>，以無頭模式運行 &mdash; 沒有視窗、沒有音效、沒有幀率限制。CPU/PPU/APU 全部以最高速度運行。單個測試 ROM 通常在 1 秒內完成。</p>

<h3>兩個腳本、兩種用途</h3>
<p>測試工作流使用兩個互補的腳本，測試清單完全一致（174 個 ROM）：</p>
<ul>
  <li><strong><code>run_tests.sh</code></strong> &mdash; 輕量驗證腳本。執行所有測試並將 PASS/FAIL 輸出到 stdout，附帶失敗摘要。用於開發過程中快速回歸檢查。</li>
  <li><strong><code>run_tests_report.sh</code></strong> &mdash; 全功能報告產生器，透過命令列參數控制模組化輸出。</li>
</ul>

<h3>報告腳本模式</h3>
<p><code>run_tests_report.sh</code> 固定將 PASS/FAIL 結果輸出到 stdout。可選參數控制額外輸出：</p>
<pre>bash run_tests_report.sh                        # 快速：僅 stdout
bash run_tests_report.sh --json                 # + 儲存 report/results.json
bash run_tests_report.sh --screenshots          # + 擷取截圖（PNG&rarr;WebP）
bash run_tests_report.sh --json --screenshots   # 完整：JSON + 截圖 + HTML 報告
bash run_tests_report.sh --no-build             # 跳過 MSBuild 編譯步驟</pre>

<p>完整流程（啟用所有參數）執行以下步驟：</p>
<ol style="margin:.5rem 0 .75rem 1.2rem;font-size:.82rem;color:var(--text-dim)">
  <li>使用 MSBuild 編譯專案（除非指定 <code>--no-build</code>）</li>
  <li>將 174 個 ROM 檔案逐一透過無頭模擬器執行</li>
  <li>將每個測試的 PASS/FAIL 輸出到 stdout</li>
  <li>若指定 <code>--screenshots</code>：擷取最終畫面為 PNG，轉換為無損 WebP</li>
  <li>若指定 <code>--json</code>：將結果收集為 <code>report/results.json</code></li>
  <li>若同時指定 <code>--json</code> 和 <code>--screenshots</code>：產生包含嵌入資料和截圖參照的單一 HTML 報告檔案（<code>report/index.html</code>）</li>
</ol>
</div>

<!-- ───────────────── 第 4 節 ───────────────── -->
<h2>4. 結果偵測機制</h2>

<div class="section">
<h3>機制 A：$6000 記憶體協定</h3>
<p>現代 blargg 測試 ROM 使用記憶體映射狀態協定。測試執行器每幀輪詢位址 <code>$6000</code>：</p>

<table>
  <tr><th>$6000 值</th><th>意義</th><th>動作</th></tr>
  <tr><td><code>$80</code></td><td>測試進行中</td><td>繼續等待</td></tr>
  <tr><td><code>$81</code></td><td>要求重設</td><td>等待 100ms 後執行軟重設</td></tr>
  <tr><td><code>$00</code></td><td>測試通過</td><td>以代碼 0 結束</td></tr>
  <tr><td><code>$01-$7F</code></td><td>測試失敗（錯誤代碼 N）</td><td>以代碼 N 結束</td></tr>
</table>

<p>結果文字從 <code>$6004+</code> 讀取，為以 null 結尾的 ASCII 字串。這提供了詳細的錯誤訊息，例如「Flag first set too late」或「Length counter not clocked correctly」。</p>

<h3>機制 B：畫面穩定偵測</h3>
<p>較舊的 blargg 測試（2005 年版）不使用 $6000 協定。它們將結果直接渲染到 PPU 名稱表。測試執行器透過多步驟啟發式方法處理這些情況：</p>
<ol style="margin:.5rem 0 .75rem 1.2rem;font-size:.82rem;color:var(--text-dim)">
  <li>在 120 幀（約 2 秒）後，開始每幀取樣畫面緩衝區</li>
  <li>計算幀緩衝區的雜湊值（每隔 37 個像素取樣以提高速度）</li>
  <li>當雜湊值連續 90 幀（約 1.5 秒）保持一致時，畫面判定為「穩定」</li>
  <li>掃描 PPU 名稱表（字元映射）尋找已知結果字串：
    <ul>
      <li><code>"Passed"</code> / <code>"PASSED"</code> &rarr; 通過</li>
      <li><code>"Failed"</code> / <code>"FAILED"</code> &rarr; 失敗</li>
      <li><code>"$01"</code>（畫面上的十六進位值）&rarr; 通過</li>
      <li><code>"$02"</code> ~ <code>"$FF"</code>（畫面上的十六進位值）&rarr; 失敗</li>
      <li><code>"All tests complete"</code> &rarr; 通過</li>
      <li><code>" 0/"</code>（零錯誤計數）&rarr; 通過</li>
    </ul>
  </li>
</ol>
<p>此方法直接讀取 PPU 名稱表（而非對像素進行 OCR），因此快速且可靠。</p>

<h3>機制 C：CRC 比對</h3>
<p>部分測試 ROM 的結果取決於開機時隨機的 CPU-PPU 同步狀態，會產生多個有效 CRC 值之一。這些測試在畫面上顯示 CRC，但無法使用單一 <code>check_crc</code> 呼叫。<code>--expected-crc</code> 參數接受以逗號分隔的有效 CRC 清單：</p>
<pre>--expected-crc "159A7A8F,5E3DF9C4"</pre>
<p>測試執行器掃描 PPU 名稱表，尋找 8 個十六進位字元組成的字串（以非十六進位字元為邊界，避免部分匹配）。找到後與期望集合進行不區分大小寫的比對。此機制同時用於畫面穩定偵測路徑和逾時備援路徑。目前用於：</p>
<ul>
  <li><code>dma_2007_read</code> &mdash; 2 個有效 CRC（取決於 CPU-PPU 同步）</li>
  <li><code>double_2007_read</code> &mdash; 4 個有效 CRC（取決於 CPU-PPU 同步）</li>
</ul>
</div>

<!-- ───────────────── 第 5 節 ───────────────── -->
<h2>5. 自動化功能</h2>

<div class="section">
<h3>自動軟重設</h3>
<p>部分測試 ROM 會寫入 <code>$81</code> 到 <code>$6000</code> 以要求主機重設（測試開機/重設行為）。執行器偵測到此情況後，會在延遲 100ms 後自動執行軟重設，模擬使用者按下重設按鈕的操作。每個 ROM 最多支援 10 次連續重設。</p>

<h3>模擬控制器輸入</h3>
<p>控制器讀取測試需要實際的按鈕輸入。<code>--input</code> 參數可排程定時按鈕事件：</p>
<pre>--input "A:2.0,B:4.0,Select:6.0,Start:8.0,Up:10.0,Down:12.0,Left:14.0,Right:16.0"</pre>
<p>每個按鈕在指定時間（秒）被按下，並持續 10 幀（約 166ms）。這使得 <code>read_joy3/test_buttons</code> 等測試能驗證所有 8 個按鈕是否被正確依序偵測。</p>

<h3>截圖擷取（可選）</h3>
<p>啟用 <code>--screenshots</code> 時，每個測試的最終畫面會被擷取為 256x240 PNG，然後轉換為無損 WebP（通常縮小 60-80%）。截圖作為視覺佐證 &mdash; 許多測試 ROM 會在畫面上以文字顯示結果，確切展示通過或失敗的項目。進行快速回歸檢查時可跳過截圖以節省時間。</p>

<h3>逾時安全機制</h3>
<p>每個 ROM 有可設定的 <code>--max-wait</code> 逾時時間（預設 30 秒，合併/多子測試 ROM 為 120 秒）。若測試 ROM 進入無限迴圈或當機，執行器會優雅地終止它並回報最後已知狀態。</p>
</div>

<!-- ───────────────── 第 6 節 ───────────────── -->
<h2>6. 測試套件涵蓋範圍</h2>

<div class="suite-grid">
  <div class="suite-item"><span class="count c-blue">4</span><span class="name">apu_mixer &mdash; 聲道混音</span></div>
  <div class="suite-item"><span class="count c-blue">6</span><span class="name">apu_reset &mdash; APU 開機/重設</span></div>
  <div class="suite-item"><span class="count c-blue">9</span><span class="name">apu_test &mdash; APU 影格計數器</span></div>
  <div class="suite-item"><span class="count c-blue">11</span><span class="name">blargg_apu_2005 &mdash; APU 時序</span></div>
  <div class="suite-item"><span class="count c-blue">2</span><span class="name">blargg_cpu_test5 &mdash; CPU 指令</span></div>
  <div class="suite-item"><span class="count c-blue">5</span><span class="name">blargg_ppu_tests &mdash; PPU 基礎</span></div>
  <div class="suite-item"><span class="count c-blue">3</span><span class="name">branch_timing &mdash; 分支週期計數</span></div>
  <div class="suite-item"><span class="count c-blue">1</span><span class="name">cpu_dummy_reads &mdash; 虛擬讀取週期</span></div>
  <div class="suite-item"><span class="count c-blue">2</span><span class="name">cpu_dummy_writes &mdash; 虛擬寫入週期</span></div>
  <div class="suite-item"><span class="count c-blue">2</span><span class="name">cpu_exec_space &mdash; 從 I/O 執行</span></div>
  <div class="suite-item"><span class="count c-blue">6</span><span class="name">cpu_interrupts_v2 &mdash; NMI/IRQ 互動</span></div>
  <div class="suite-item"><span class="count c-blue">2</span><span class="name">cpu_reset &mdash; CPU 重設行為</span></div>
  <div class="suite-item"><span class="count c-blue">1</span><span class="name">cpu_timing_test6 &mdash; 指令時序</span></div>
  <div class="suite-item"><span class="count c-blue">5</span><span class="name">dmc_dma_during_read &mdash; DMC DMA 衝突</span></div>
  <div class="suite-item"><span class="count c-blue">5</span><span class="name">instr_misc &mdash; 雜項指令測試</span></div>
  <div class="suite-item"><span class="count c-blue">17</span><span class="name">instr_test-v3 &mdash; 全部 6502 指令</span></div>
  <div class="suite-item"><span class="count c-blue">18</span><span class="name">instr_test-v5 &mdash; 全部 6502 指令（v5）</span></div>
  <div class="suite-item"><span class="count c-blue">3</span><span class="name">instr_timing &mdash; 指令週期時序</span></div>
  <div class="suite-item"><span class="count c-blue">6</span><span class="name">mmc3_irq_tests &mdash; MMC3 IRQ 計數器</span></div>
  <div class="suite-item"><span class="count c-blue">6</span><span class="name">mmc3_test &mdash; MMC3 行為</span></div>
  <div class="suite-item"><span class="count c-blue">6</span><span class="name">mmc3_test_2 &mdash; MMC3 行為（v2）</span></div>
  <div class="suite-item"><span class="count c-blue">11</span><span class="name">nes_instr_test &mdash; CPU 指令（替代版）</span></div>
  <div class="suite-item"><span class="count c-blue">1</span><span class="name">oam_read &mdash; OAM 讀取行為</span></div>
  <div class="suite-item"><span class="count c-blue">1</span><span class="name">ppu_open_bus &mdash; PPU 開放匯流排</span></div>
  <div class="suite-item"><span class="count c-blue">1</span><span class="name">ppu_read_buffer &mdash; PPU 讀取緩衝區</span></div>
  <div class="suite-item"><span class="count c-blue">11</span><span class="name">ppu_vbl_nmi &mdash; VBlank/NMI 時序</span></div>
  <div class="suite-item"><span class="count c-blue">4</span><span class="name">read_joy3 &mdash; 控制器讀取</span></div>
  <div class="suite-item"><span class="count c-blue">2</span><span class="name">sprdma_and_dmc_dma &mdash; DMA 衝突</span></div>
  <div class="suite-item"><span class="count c-blue">11</span><span class="name">sprite_hit_tests &mdash; 精靈 0 命中</span></div>
  <div class="suite-item"><span class="count c-blue">5</span><span class="name">sprite_overflow &mdash; 精靈溢位</span></div>
  <div class="suite-item"><span class="count c-blue">7</span><span class="name">vbl_nmi_timing &mdash; VBL/NMI 時序</span></div>
</div>

<!-- ───────────────── 第 7 節 ───────────────── -->
<h2>7. 命令列介面</h2>

<div class="section">
<p>無頭測試執行器透過模擬器執行檔直接呼叫：</p>
<pre>AprNes.exe --rom &lt;file.nes&gt; [選項]</pre>

<table>
  <tr><th>選項</th><th>說明</th></tr>
  <tr><td><code>--rom &lt;path&gt;</code></td><td>要載入的 ROM 檔案（必填）</td></tr>
  <tr><td><code>--wait-result</code></td><td>監控 $6000 / 畫面以偵測測試結果</td></tr>
  <tr><td><code>--max-wait &lt;sec&gt;</code></td><td>逾時秒數（預設：30）</td></tr>
  <tr><td><code>--time &lt;sec&gt;</code></td><td>精確執行 N 秒後停止</td></tr>
  <tr><td><code>--screenshot &lt;path&gt;</code></td><td>將最終畫面儲存為 PNG</td></tr>
  <tr><td><code>--log &lt;path&gt;</code></td><td>將結果寫入檔案</td></tr>
  <tr><td><code>--soft-reset &lt;sec&gt;</code></td><td>在第 N 秒觸發軟重設</td></tr>
  <tr><td><code>--input &lt;spec&gt;</code></td><td>排程按鈕輸入（例如 "A:2.0,B:4.0"）</td></tr>
  <tr><td><code>--expected-crc &lt;list&gt;</code></td><td>以逗號分隔的有效 CRC 清單，用於 CRC-only 測試（例如 "159A7A8F,5E3DF9C4"）</td></tr>
  <tr><td><code>--debug-log &lt;path&gt;</code></td><td>寫入 CPU 追蹤日誌</td></tr>
</table>

<p>結束代碼：<code>0</code> = 通過、<code>1-127</code> = 失敗（測試錯誤代碼）、<code>255</code> = 逾時/無結果。</p>
</div>

<!-- ───────────────── 第 8 節 ───────────────── -->
<h2>8. 模擬器支援 QA 流程的設計介面</h2>

<p>要採用此自動化 QA 工作流，模擬器必須開放一組設計介面。以下是基於 AprNes 架構的參考 &mdash; 此模式適用於任何 NES 模擬器，不限程式語言。</p>

<div class="section">
<h3>8.1 雙重進入點：GUI 與無頭模式</h3>
<p>模擬器應從單一執行檔支援兩種運作模式。當有命令列參數時進入無頭測試模式；否則啟動正常 GUI。</p>
<pre>// Program.cs — 進入點
static int Main(string[] args)
{
    if (args.Length > 0)
        return TestRunner.Run(args);    // 無頭模式，回傳結束代碼

    Application.Run(new MainForm());    // 正常 GUI 模式
    return 0;
}</pre>
<p>重點：<code>Main()</code> 回傳 <code>int</code>（非 <code>void</code>），讓結束代碼可向呼叫腳本傳遞通過/失敗訊號。</p>
</div>

<div class="section">
<h3>8.2 無頭模式旗標</h3>
<p>模擬器核心需要靜態旗標，在測試模式下抑制 GUI 和音訊子系統：</p>

<table>
  <tr><th>旗標</th><th>用途</th><th>效果</th></tr>
  <tr><td><code>HeadlessMode = true</code></td><td>抑制視窗建立</td><td>不實例化 Form/Window；渲染仍然執行以填充幀緩衝區，但不產生顯示輸出</td></tr>
  <tr><td><code>AudioEnabled = false</code></td><td>抑制音訊輸出</td><td>APU 仍然計時（時序測試需要），但不開啟音訊裝置</td></tr>
  <tr><td><code>LimitFPS = false</code></td><td>移除幀率限制器</td><td>模擬以最高 CPU 速度執行；30 秒的測試在不到 1 秒的實際時間內完成</td></tr>
  <tr><td><code>exit = true</code></td><td>通知主迴圈停止</td><td>由測試執行器在偵測到結果時設定；<code>run()</code> 迴圈每幀檢查此旗標</td></tr>
</table>

<p>這些旗標讓 CPU/PPU/APU 繼續正常計時 &mdash; 只有 I/O 端點（螢幕、喇叭）被停用。這確保時序敏感的測試在無頭和 GUI 模式下產生相同的結果。</p>
</div>

<div class="section">
<h3>8.3 逐幀回呼（VideoOutput 事件）</h3>
<p>模擬器必須提供每幀渲染完畢後觸發的掛鈎。測試執行器訂閱此事件來輪詢結果：</p>
<pre>// 在 NesCore（模擬器核心）中：
public static event EventHandler VideoOutput;

// 在每個 PPU 幀結束時觸發（掃描線 240，VBlank 開始後）：
VideoOutput?.Invoke(null, null);

// 在 TestRunner 中：
NesCore.VideoOutput += (sender, e) => {
    frameCount++;
    byte status = NesCore.NES_MEM[0x6000];  // 輪詢測試協定
    // ... 偵測結果，完成時設定 NesCore.exit = true
};</pre>
<p>此回呼驅動的設計避免了緊密輪詢迴圈，並能整合 GUI（重繪畫面）和無頭（檢查測試狀態）兩種模式。</p>
</div>

<div class="section">
<h3>8.4 記憶體和 PPU RAM 存取</h3>
<p>測試執行器需要直接讀取兩個記憶體區域：</p>

<table>
  <tr><th>記憶體區域</th><th>存取方式</th><th>用途</th></tr>
  <tr><td><code>NES_MEM[0x6000..0x6FFF]</code></td><td>CPU 位址空間（WRAM）</td><td>讀取 $6000 狀態位元組和 $6004+ 結果文字（blargg 協定）</td></tr>
  <tr><td><code>ppu_ram[0x2000..0x23BF]</code></td><td>PPU 名稱表 0</td><td>掃描畫面上的 "Passed"/"Failed" 文字（較舊的測試 ROM）</td></tr>
  <tr><td><code>ScreenBuf1x[0..61439]</code></td><td>已渲染幀緩衝區（256x240 ARGB）</td><td>畫面穩定性雜湊 + 截圖擷取</td></tr>
</table>

<p>這些必須以靜態指標或陣列方式公開 &mdash; 每幀不需複製。測試執行器在 <code>VideoOutput</code> 回呼內同步讀取它們，因此執行緒安全由幀邊界保證。</p>
</div>

<div class="section">
<h3>8.5 軟重設 API</h3>
<p>部分測試 ROM 透過寫入 <code>$81</code> 到 <code>$6000</code> 來要求主機重設。模擬器必須提供 <code>SoftReset()</code> 方法，重設 CPU/APU 狀態但不重新載入 ROM：</p>
<pre>public static void SoftReset()
{
    // 重設 CPU：從 $FFFC/$FFFD 讀取重設向量，清除暫存器
    // 重設 APU：重新初始化影格計數器，靜音聲道
    // 不完全重設 PPU（某些測試依賴 PPU 狀態在重設後存留）
    // 不卸載 ROM，不重新初始化 mapper
}</pre>
<p>這與硬重設（電源循環）不同。測試執行器在偵測到 <code>$6000 == $81</code> 後延遲 100ms（約 6 幀）呼叫 <code>SoftReset()</code>。</p>
</div>

<div class="section">
<h3>8.6 控制器輸入注入</h3>
<p>控制器測試需要程式化的按鈕操作。模擬器必須公開按下/釋放方法：</p>
<pre>public static void P1_ButtonPress(byte buttonIndex);   // 0=A,1=B,2=Sel,3=Start,4=Up,5=Down,6=Left,7=Right
public static void P1_ButtonUnPress(byte buttonIndex);</pre>
<p>測試執行器依幀號排程事件。每個按鈕在指定的幀按下，並在可設定的持續時間後釋放（預設 10 幀 &asymp; 166ms）。</p>
</div>

<div class="section">
<h3>8.7 ROM 載入 API</h3>
<p>模擬器需要基於位元組陣列的簡單 ROM 載入介面：</p>
<pre>public static bool init(byte[] rom_bytes);  // 解析 iNES 標頭，設定 mapper，重設 CPU
public static void run();                    // 主模擬迴圈（阻塞直到 exit==true）</pre>
<p><code>init()</code> 在不支援的 mapper 或損壞標頭時回傳 <code>false</code>。<code>run()</code> 由測試執行器在背景執行緒上呼叫，透過 <code>Thread.Join()</code> 等待完成。</p>
</div>

<div class="section">
<h3>8.8 架構總覽</h3>

<div class="flow">
  <div class="step"><div class="title">Program.cs</div><div class="desc">進入點<br>GUI / 無頭分流</div></div>
  <span class="arrow">&rarr;</span>
  <div class="step"><div class="title">TestRunner.cs</div><div class="desc">參數解析<br>逐幀回呼<br>結果偵測</div></div>
  <span class="arrow">&rarr;</span>
  <div class="step"><div class="title">NesCore</div><div class="desc">init() / run()<br>HeadlessMode 旗標<br>VideoOutput 事件</div></div>
</div>

<p>設計原則是<strong>最小耦合</strong>：測試執行器透過 8 個接觸點（3 個旗標、1 個事件、3 個記憶體區域、1 個重設方法）與模擬器核心互動。模擬器核心完全不需要了解測試執行器 &mdash; 它只需檢查 <code>HeadlessMode</code> 來跳過 GUI 建立，並在每幀觸發 <code>VideoOutput</code>。所有測試邏輯都在 <code>TestRunner.cs</code> 中。</p>

<table>
  <tr><th>介面</th><th>方向</th><th>類型</th></tr>
  <tr><td><code>HeadlessMode</code></td><td>TestRunner &rarr; Core</td><td>靜態布林旗標</td></tr>
  <tr><td><code>AudioEnabled</code></td><td>TestRunner &rarr; Core</td><td>靜態布林旗標</td></tr>
  <tr><td><code>LimitFPS</code></td><td>TestRunner &rarr; Core</td><td>靜態布林旗標</td></tr>
  <tr><td><code>exit</code></td><td>TestRunner &rarr; Core</td><td>靜態布林旗標</td></tr>
  <tr><td><code>VideoOutput</code></td><td>Core &rarr; TestRunner</td><td>事件（逐幀回呼）</td></tr>
  <tr><td><code>NES_MEM / ppu_ram / ScreenBuf1x</code></td><td>Core &rarr; TestRunner</td><td>靜態記憶體指標（唯讀）</td></tr>
  <tr><td><code>SoftReset()</code></td><td>TestRunner &rarr; Core</td><td>靜態方法</td></tr>
  <tr><td><code>P1_ButtonPress/UnPress()</code></td><td>TestRunner &rarr; Core</td><td>靜態方法</td></tr>
  <tr><td><code>init(byte[]) / run()</code></td><td>TestRunner &rarr; Core</td><td>靜態方法</td></tr>
</table>

<p>此架構使 QA 系統具有<strong>可移植性</strong>：任何開放這些介面的 NES 模擬器都能使用相同的 bash 腳本和測試 ROM 合集進行自動化回歸測試，不受其內部實作方式限制。</p>
</div>

<h2>9. 以 Claude Code 驅動的 AI 輔助開發流程</h2>

<div class="section">
<h3>9.1 概述</h3>
<p>AprNes 使用 <a href="https://docs.anthropic.com/en/docs/claude-code">Claude Code</a>（Anthropic 的 CLI 代理工具）作為 AI 配對程式設計師，直接呼叫測試 shell 腳本、讀取失敗輸出、診斷根因、編輯原始碼並驗證修復 — 全部在一個迭代迴圈中完成。第 1-8 節描述的測試基礎建設是此流程得以運作的基石。</p>

<div class="flow">
  <div class="step"><div class="title">TODO.md</div><div class="desc">選取下個 bug</div></div>
  <div class="arrow">&rarr;</div>
  <div class="step"><div class="title">分析</div><div class="desc">跑失敗測試<br>讀測試 ROM 原始碼</div></div>
  <div class="arrow">&rarr;</div>
  <div class="step"><div class="title">規劃</div><div class="desc">根因 + 修復設計</div></div>
  <div class="arrow">&rarr;</div>
  <div class="step"><div class="title">實作</div><div class="desc">編輯模擬器程式碼</div></div>
  <div class="arrow">&rarr;</div>
  <div class="step"><div class="title">驗證</div><div class="desc">編譯 &amp; 跑測試</div></div>
  <div class="arrow">&rarr;</div>
  <div class="step"><div class="title">記錄</div><div class="desc">bugfix/ + TODO.md<br>git commit &amp; push</div></div>
</div>
</div>

<div class="section">
<h3>9.2 前置條件</h3>
<ul>
  <li><strong>Claude Code CLI</strong> — 安裝並認證（<code>npm install -g @anthropic-ai/claude-code</code>）</li>
  <li><strong>專案記憶</strong> — <code>.claude/</code> 目錄中的 <code>MEMORY.md</code> 記錄架構、編譯指令和慣例，讓 AI 跨對話保留上下文</li>
  <li><strong>測試腳本</strong> — <code>run_tests.sh</code>（快速驗證）和 <code>run_tests_report.sh</code>（含 JSON/截圖的完整報告）</li>
  <li><strong>測試 ROM</strong> — <code>nes-test-roms-master/checked/</code> 包含所有測試套件</li>
  <li><strong>TODO.md</strong> — 按優先權排序的 bug 清單，附帶失敗詳情，作為任務佇列</li>
</ul>
</div>

<div class="section">
<h3>9.3 逐步流程</h3>

<h3>階段 1：任務選取</h3>
<p>開發者告訴 Claude Code 讀取 <code>TODO.md</code> 並繼續下個任務。Claude 選取最高優先權的未完成 bug，識別相關的失敗測試。</p>
<pre>User: 閱讀 TODO.MD，繼續後面任務
Claude: [讀取 TODO.md，識別 "Bug G — Sprite timing" 為下個目標]
        [跑 4 個失敗測試並截圖，記錄當前狀態]</pre>

<h3>階段 2：根因分析</h3>
<p>Claude 利用測試基礎建設來診斷 bug：</p>
<ul>
  <li><strong>逐個執行失敗的測試 ROM</strong>，透過 headless CLI 擷取 exit code 和畫面輸出</li>
  <li><strong>閱讀測試 ROM 組語原始碼</strong>，了解測試期望的精確行為（cycle 計數、flag 時序等）</li>
  <li><strong>閱讀模擬器原始碼</strong>（PPU.cs、CPU.cs、APU.cs 等）找出差異</li>
  <li><strong>交叉比對</strong> NES 硬體文件（nesdev wiki）與模擬器實作</li>
</ul>
<pre># Claude 逐個跑失敗測試，看精確的錯誤訊息
./AprNes/bin/Debug/AprNes.exe --wait-result --max-wait 30 \
  --rom nes-test-roms-master/checked/sprite_hit_tests_2005.10.05/09.timing_basics.nes
# → FAIL #3: "upper-left corner too late"</pre>

<h3>階段 3：規劃模式</h3>
<p>對於非簡單的修復，Claude 進入<strong>規劃模式（plan mode）</strong>— 一個唯讀狀態，在不修改任何檔案的情況下設計實作策略。規劃內容包括：</p>
<ul>
  <li>含硬體時序細節的根因解釋</li>
  <li>具體的程式碼修改，精確到行號</li>
  <li>回歸風險分析（哪些現有 PASS 測試可能被影響）</li>
  <li>實作後要執行的驗證命令</li>
</ul>
<p>開發者審核並批准規劃後，才開始修改程式碼。</p>

<h3>階段 4：實作</h3>
<p>Claude 使用精確的文字替換編輯模擬器原始碼。每個變更都是有針對性且最小化的 — 只修改規劃中指定的內容。</p>

<h3>階段 5：編譯與驗證</h3>
<p>Claude 直接呼叫編譯工具鏈和測試腳本：</p>
<pre># 1. 編譯
powershell -NoProfile -Command "MSBuild.exe AprNes.sln /p:Configuration=Debug /t:Rebuild"

# 2. 跑目標測試（我們要修的那些）
./AprNes/bin/Debug/AprNes.exe --wait-result --max-wait 30 \
  --rom nes-test-roms-master/checked/sprite_hit_tests_2005.10.05/09.timing_basics.nes

# 3. 跑回歸套件（可能受影響的相關測試）
for rom in 01.basics.nes 02.alignment.nes ... 11.edge_timing.nes; do
  ./AprNes/bin/Debug/AprNes.exe --wait-result --max-wait 30 \
    --rom "nes-test-roms-master/checked/sprite_hit_tests_2005.10.05/$rom"
done

# 4. 完整回歸（全部 174 個測試）
bash run_tests.sh</pre>
<p>如果有測試意外失敗，Claude 讀取失敗輸出、調整修復、重新執行。這個內部迴圈重複直到所有目標測試通過且零回歸。</p>

<h3>階段 6：記錄與提交</h3>
<p>驗證通過後，Claude：</p>
<ul>
  <li>更新 <code>TODO.md</code> — 將 bug 標記為已完成，更新基線數字</li>
  <li>建立 <code>bugfix/YYYY-MM-DD_BUGFIXNN.md</code> — 詳細記錄問題、根因、修復和測試結果</li>
  <li>提交描述性的 commit message：<code>fix sprite timing: per-pixel hit + cycle-accurate overflow: 165 PASS / 9 FAIL (+4)</code></li>
  <li>推送至遠端</li>
</ul>

<h3>階段 7：報告產生（按需）</h3>
<p>開發者可隨時要求產生完整的 HTML 報告：</p>
<pre>bash run_tests_report.sh --json --screenshots
# → report/index.html（含截圖的互動式儀表板）</pre>
</div>

<div class="section">
<h3>9.4 流程中的關鍵檔案</h3>

<table>
  <tr><th>檔案</th><th>角色</th></tr>
  <tr><td><code>TODO.md</code></td><td>按優先權排序的 bug 清單 — 驅動每次工作的任務佇列</td></tr>
  <tr><td><code>.claude/memory/MEMORY.md</code></td><td>持久化 AI 記憶：架構、編譯指令、慣例</td></tr>
  <tr><td><code>bugfix/YYYY-MM-DD_BUGFIXNN.md</code></td><td>逐次修復的文件：問題、根因、變更、驗證</td></tr>
  <tr><td><code>run_tests.sh</code></td><td>快速驗證 — 跑全部 174 個測試，輸出 PASS/FAIL 計數</td></tr>
  <tr><td><code>run_tests_report.sh</code></td><td>完整報告 — JSON 資料 + 截圖 + HTML 儀表板</td></tr>
  <tr><td><code>report/index.html</code></td><td>產出的互動式測試報告，支援篩選和瀏覽</td></tr>
</table>
</div>

<div class="section">
<h3>9.5 為何此流程有效</h3>
<ul>
  <li><strong>確定性回饋</strong> — 測試 ROM 產生二元的 PASS/FAIL，附帶精確的失敗描述（如 "upper-left corner too late"），給 AI 明確的訊號</li>
  <li><strong>Headless CLI</strong> — 模擬器的 <code>--wait-result</code> 模式回傳機器可讀的 exit code（0=通過, 1=失敗），實現自動化驗證迴圈</li>
  <li><strong>結構化知識</strong> — <code>TODO.md</code> 提供排序好的任務上下文；<code>MEMORY.md</code> 跨對話攜帶架構知識；<code>bugfix/</code> 記錄每次變更背後的推理</li>
  <li><strong>快速迭代</strong> — 編譯 + 單一測試約 5 秒；完整 174 測試回歸不到 10 分鐘。AI 可以在一次對話中嘗試多種方案</li>
  <li><strong>人工監督</strong> — 規劃模式確保開發者在任何程式碼變更前審核方案。Git commit 是明確的檢查點</li>
</ul>
</div>

<div class="section">
<h3>9.6 實際案例：BUGFIX17（Sprite 時序）</h3>
<p>單次 Claude Code 對話從 161 PASS 進步到 165 PASS (+4)，過程如下：</p>
<ol style="margin:.5rem 0 .75rem 1.2rem;font-size:.82rem;color:var(--text-dim)">
  <li>讀取 <code>TODO.md</code> → 識別 Bug G（4 個 sprite 測試失敗）</li>
  <li>逐個跑失敗測試 → 擷取精確錯誤訊息（#3 "too late"、#5 "set too late"、#2 "byte offset bug"）</li>
  <li>閱讀測試 ROM 組語原始碼（09.timing_basics.asm、3.Timing.a、4.Obscure.a）→ 理解期望的 cycle 計數</li>
  <li>閱讀 PPU.cs → 發現 phase 7 批次渲染（7-dot 延遲）和 cycle-257 overflow 偵測</li>
  <li>進入規劃模式 → 設計 3 個修復：逐像素 hit 偵測、cycle 精確 overflow、硬體 overflow bug</li>
  <li>在 PPU.cs 中實作全部 3 個修復（+120 行，-40 行）</li>
  <li>編譯 → 跑 4 個目標測試（全 PASS）→ 跑 sprite 回歸（14 測試，全 PASS）→ 跑完整套件（165 PASS / 9 FAIL）</li>
  <li>更新 TODO.md、建立 BUGFIX17.md、commit 並 push</li>
</ol>
<p>總計：識別 3 個根因、實作 3 個修復、0 個回歸 — 全部在單次對話中完成。</p>
</div>

<div class="section">
<h3>9.7 實際案例：BUGFIX19（DMC DMA Cycle Stealing）</h3>
<p>一個跨多次對話的 Claude Code 工作流從 169 PASS 進步到 171 PASS (+2)，解決了架構上最具挑戰性的 bug — DMC DMA cycle stealing：</p>
<ol style="margin:.5rem 0 .75rem 1.2rem;font-size:.82rem;color:var(--text-dim)">
  <li>讀取 <code>TODO.md</code> → 識別 Bug F（5 個 DMC DMA 測試失敗，標記為「需要架構重構」）</li>
  <li>研究 NESdev Wiki DMA 參考文件（來自 <code>ref/</code> 目錄）→ 發現 Load DMA 與 Reload DMA 的差異</li>
  <li>閱讀測試 ROM 組語原始碼（sync_dmc.s、sprdma_and_dmc_dma.s、dma_2007_read.s、dma_4016_read.s）</li>
  <li>進入規劃模式 → 設計 5 部分修復：CPU bus state tracking、PPU-only stolen tick、Load/Reload cycle model、phantom reads、OAM DMA bus tracking</li>
  <li>橫跨 3 個核心檔案實作（MEM.cs、APU.cs、PPU.cs）→ +200 行 cycle-accurate DMA 模擬</li>
  <li>發現 2 個測試（dma_2007_read、double_2007_read）產生正確 CRC 但從不印 "Passed" → 在 TestRunner.cs 新增 <code>--expected-crc</code> 參數支援 CRC-only 測試</li>
  <li>迭代除錯：基於 parity 的模型導致 sync_dmc 收斂失敗 → 替換為基於 Load/Reload 類型的模型</li>
  <li>完整回歸：171 PASS / 3 FAIL，0 個回歸</li>
</ol>
<p>此修復需要理解 NES DMA 的 bus-cycle 層級行為：GET/PUT 節奏、halt 排程、write-delay 規則、phantom read /OE 連續性。剩餘 1 個 DMC 測試失敗（double_2007_read）被識別為獨立的 PPU buffer latch 時序問題，而非 DMA bug。</p>
</div>

<div class="footer"><a href="index.html">測試報告</a> | AprNes 測試方法論</div>

</body>
</html>
