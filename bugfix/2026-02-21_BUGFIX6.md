# AprNes Bug 修復紀錄（第六輯）

本文件接續 `BUGFIX5.md`（Bug 16–26），記錄 commit `0fdd934` 修復的 Bug 27–31。
所有修復均已 commit 至 master 分支。

---

## 目錄

27. [非官方 abs,X RMW opcode 缺少 wrong-page dummy read](#27-非官方-absx-rmw-opcode-缺少-wrong-page-dummy-read)
28. [非官方 abs,Y RMW opcode 缺少 wrong-page dummy read](#28-非官方-absy-rmw-opcode-缺少-wrong-page-dummy-read)
29. [非官方 (ind),Y RMW opcode 缺少 wrong-page dummy read](#29-非官方-indy-rmw-opcode-缺少-wrong-page-dummy-read)
30. [SHY/SHX/LAX 缺少 dummy read](#30-shyshxlax-缺少-dummy-read)
31. [未實作非官方 opcode TAS/SHA/LAS](#31-未實作非官方-opcode-tasshalas)

---

## 27. 非官方 abs,X RMW opcode 缺少 wrong-page dummy read

**Commit**：`0fdd934`

### 現象

blargg `instr_misc/04-dummy_reads_apu.nes` 測試失敗，報告 21 個 opcode 的
dummy read 行為不正確。測試使用 APU $4015 IRQ flag 偵測 CPU 是否在正確的
cycle 讀取了 I/O 暫存器。

### 根本原因

6502 CPU 在 absolute,X 定址的 Read-Modify-Write（RMW）指令中，**無論是否跨頁**，
都必須先從 "wrong page" 位址（高位元組未修正）執行一次 dummy read。
這是 7 個 CPU cycle 中的第 4 個 cycle：

```
Cycle 1: fetch opcode
Cycle 2: fetch addr low (BAL)
Cycle 3: fetch addr high (BAH)
Cycle 4: read from BAH:BAL+X (wrong page, 不修正進位) ← 缺少
Cycle 5: read from correct address
Cycle 6: write original value (dummy write)
Cycle 7: write modified value
```

原始實作直接計算 `(base + X)` 為最終位址，跳過了 cycle 4 的 dummy read。

### 受影響 opcode

| Opcode | 指令 | 說明 |
|--------|------|------|
| 0x1F | SLO abs,X | ASL M then ORA |
| 0x3F | RLA abs,X | ROL M then AND |
| 0x5F | SRE abs,X | LSR M then EOR |
| 0x7F | RRA abs,X | ROR M then ADC |
| 0xDF | DCP abs,X | DEC M then CMP |
| 0xFF | ISC abs,X | INC M then SBC |

### 修復方式

將位址計算拆分，在讀取正確位址之前，先從 wrong-page 位址做 dummy read：

```csharp
// 修復前
ushort1 = (ushort)((Mem_r(r_PC++) | (Mem_r(r_PC++) << 8)) + r_X);
byte1 = Mem_r(ushort1);

// 修復後
ushort2 = (ushort)(Mem_r(r_PC++) | (Mem_r(r_PC++) << 8));  // base address
ushort1 = (ushort)(ushort2 + r_X);                          // final address
Mem_r((ushort)((ushort2 & 0xFF00) | (ushort1 & 0x00FF)));   // dummy read: BAH:BAL+X (no carry fix)
byte1 = Mem_r(ushort1);                                     // real read
```

Wrong-page 位址的計算方式：取 base 的高位元組、final 的低位元組，
即 `(BAH << 8) | ((BAL + X) & 0xFF)`。無論是否跨頁，CPU 硬體都會做這個讀取。

---

## 28. 非官方 abs,Y RMW opcode 缺少 wrong-page dummy read

**Commit**：`0fdd934`

### 現象

同 Bug 27，`04-dummy_reads_apu.nes` 測試報告這些 opcode 的 dummy read 不正確。

### 根本原因

與 Bug 27 相同的問題，但使用 Y 暫存器做索引。abs,Y RMW 的 cycle 結構與
abs,X 完全一致，cycle 4 同樣需要 wrong-page dummy read。

### 受影響 opcode

| Opcode | 指令 | 說明 |
|--------|------|------|
| 0x1B | SLO abs,Y | ASL M then ORA |
| 0x3B | RLA abs,Y | ROL M then AND |
| 0x5B | SRE abs,Y | LSR M then EOR |
| 0x7B | RRA abs,Y | ROR M then ADC |
| 0xDB | DCP abs,Y | DEC M then CMP |
| 0xFB | ISC abs,Y | INC M then SBC |

### 修復方式

與 Bug 27 相同模式，改為 `r_Y`：

```csharp
ushort2 = (ushort)(Mem_r(r_PC++) | (Mem_r(r_PC++) << 8));
ushort1 = (ushort)(ushort2 + r_Y);
Mem_r((ushort)((ushort2 & 0xFF00) | (ushort1 & 0x00FF))); // wrong-page dummy read
byte1 = Mem_r(ushort1);
```

---

## 29. 非官方 (ind),Y RMW opcode 缺少 wrong-page dummy read

**Commit**：`0fdd934`

### 現象

同 Bug 27，`04-dummy_reads_apu.nes` 測試報告這些 opcode 的 dummy read 不正確。

### 根本原因

(indirect),Y 定址的 RMW 指令使用 8 個 CPU cycle：

```
Cycle 1: fetch opcode
Cycle 2: fetch pointer address (ZP)
Cycle 3: fetch addr low from ZP
Cycle 4: fetch addr high from ZP+1
Cycle 5: read from BAH:BAL+Y (wrong page, 不修正進位) ← 缺少
Cycle 6: read from correct address
Cycle 7: write original value (dummy write)
Cycle 8: write modified value
```

原始實作直接將 indirect 取得的 base 加上 Y 做為最終位址，跳過了 cycle 5。
此外，原始程式碼在間接位址取值和最終位址計算之間沒有區分，寫法為：

```csharp
ushort1 = (ushort)((NES_MEM[byte2++] | (NES_MEM[byte2] << 8)) + r_Y);
```

### 受影響 opcode

| Opcode | 指令 | 說明 |
|--------|------|------|
| 0x13 | SLO (ind),Y | ASL M then ORA |
| 0x33 | RLA (ind),Y | ROL M then AND |
| 0x53 | SRE (ind),Y | LSR M then EOR |
| 0x73 | RRA (ind),Y | ROR M then ADC |
| 0xD3 | DCP (ind),Y | DEC M then CMP |
| 0xF3 | ISC (ind),Y | INC M then SBC |

### 修復方式

拆分間接定址取值和 Y 偏移計算：

```csharp
// 修復前
byte2 = Mem_r(r_PC++);
ushort1 = (ushort)((NES_MEM[byte2++] | (NES_MEM[byte2] << 8)) + r_Y);
byte1 = Mem_r((ushort)(ushort1));

// 修復後
byte2 = Mem_r(r_PC++);
ushort2 = (ushort)(NES_MEM[byte2++] | (NES_MEM[byte2] << 8));  // indirect base
ushort1 = (ushort)(ushort2 + r_Y);                              // final address
Mem_r((ushort)((ushort2 & 0xFF00) | (ushort1 & 0x00FF)));       // wrong-page dummy read
byte1 = Mem_r(ushort1);                                         // real read
```

---

## 30. SHY/SHX/LAX 缺少 dummy read

**Commit**：`0fdd934`

### 現象

同 Bug 27，`04-dummy_reads_apu.nes` 測試報告 SHY、SHX、LAX 的 dummy read 不正確。

### 根本原因

三種不同類型的缺失 dummy read：

**SHY (0x9C) / SHX (0x9E) — Write abs,X/Y**

SHY 和 SHX 是 write 指令，使用 5 個 CPU cycle。
Cycle 4 **無論是否跨頁**都必須讀取 wrong-page 位址（與 RMW 一致），
但原始實作缺少此讀取。

```
Cycle 1: fetch opcode
Cycle 2: fetch addr low
Cycle 3: fetch addr high
Cycle 4: read from wrong-page address ← 缺少
Cycle 5: write to correct/glitched address
```

**LAX abs,Y (0xBF) / LAX (ind),Y (0xB3) — Read abs,Y**

LAX 是 read 指令，使用 4+1 個 CPU cycle。
**僅在跨頁時**才需要 wrong-page dummy read（與官方 LDA abs,Y 一致），
但原始實作缺少此讀取。

### 修復方式

**SHY/SHX**：在計算 wrong-page 位址後、跨頁修正前，加入 dummy read：

```csharp
// SHY (0x9C) 修復
ushort1 = (ushort)(Mem_r(r_PC++) | (Mem_r(r_PC++) << 8));
byte1 = (byte)(r_Y & (((ushort1 & 0xff00) >> 8) + 1));
ushort1 = (ushort)((ushort1 & 0xff00) | (byte)(ushort1 + r_X));
Mem_r(ushort1);  // ← 新增 dummy read at wrong-page address
if ((ushort1 & 0xff) < r_X) ushort1 = (ushort)((ushort1 & 0xff) | (byte1 << 8));
Mem_w(ushort1, byte1);
```

**LAX**：加入 page-cross 條件判斷的 dummy read：

```csharp
// LAX abs,Y (0xBF) 修復
ushort2 = (ushort)(Mem_r(r_PC++) | (Mem_r(r_PC++) << 8));
ushort1 = (ushort)(ushort2 + r_Y);
if ((ushort1 & 0xFF00) != (ushort2 & 0xFF00))  // page cross
    Mem_r((ushort)((ushort2 & 0xFF00) | (ushort1 & 0x00FF)));  // dummy read
r_X = r_A = Mem_r(ushort1);
```

---

## 31. 未實作非官方 opcode TAS/SHA/LAS

**Commit**：`0fdd934`

### 現象

`instr_misc/04-dummy_reads_apu.nes` 測試執行到 opcode 0x9B 時，
模擬器拋出 "unknown opcode 0x9B" 錯誤並崩潰。

### 根本原因

以下 4 個非官方 opcode 完全未實作，被歸類為 unknown opcode：

| Opcode | 助記符 | 定址模式 | 說明 |
|--------|--------|---------|------|
| 0x9B | TAS/SHS | abs,Y | SP = A & X; write SP & (H+1) |
| 0x9F | SHA/AXA | abs,Y | write A & X & (H+1) |
| 0x93 | SHA/AXA | (ind),Y | write A & X & (H+1) |
| 0xBB | LAS/LAR | abs,Y | A = X = SP = M & SP |

這些 opcode 雖然不穩定（在不同 NES 硬體上行為可能不同），
但 blargg 的 dummy read 測試會執行每一個 opcode，
因此必須提供基本實作以避免崩潰。

### 修復方式

**TAS/SHS (0x9B)**：先將 SP 設為 A & X，再寫入 SP & (H+1) 至目標位址。
屬於 write abs,Y 類型，必須包含 wrong-page dummy read：

```csharp
case 0x9B://TAS/SHS abs,Y
    ushort1 = (ushort)(Mem_r(r_PC++) | (Mem_r(r_PC++) << 8));
    r_SP = (byte)(r_A & r_X);
    byte1 = (byte)(r_SP & (((ushort1 & 0xff00) >> 8) + 1));
    ushort1 = (ushort)((ushort1 & 0xff00) | (byte)(ushort1 + r_Y));
    Mem_r(ushort1); // dummy read
    if ((ushort1 & 0xff) < r_Y)
        ushort1 = (ushort)((ushort1 & 0xff) | (byte1 << 8)); // page-cross glitch
    Mem_w(ushort1, byte1);
    break;
```

**SHA/AXA abs,Y (0x9F)**：寫入 A & X & (H+1)，write abs,Y 類型：

```csharp
case 0x9F://SHA/AXA abs,Y
    ushort1 = (ushort)(Mem_r(r_PC++) | (Mem_r(r_PC++) << 8));
    byte1 = (byte)(r_A & r_X & (((ushort1 & 0xff00) >> 8) + 1));
    ushort1 = (ushort)((ushort1 & 0xff00) | (byte)(ushort1 + r_Y));
    Mem_r(ushort1); // dummy read
    if ((ushort1 & 0xff) < r_Y)
        ushort1 = (ushort)((ushort1 & 0xff) | (byte1 << 8));
    Mem_w(ushort1, byte1);
    break;
```

**SHA/AXA (ind),Y (0x93)**：同 SHA 但使用 (indirect),Y 定址：

```csharp
case 0x93://SHA/AXA (ind),Y
    byte2 = Mem_r(r_PC++);
    ushort2 = (ushort)(NES_MEM[byte2++] | (NES_MEM[byte2] << 8));
    ushort1 = (ushort)(ushort2 + r_Y);
    byte1 = (byte)(r_A & r_X & (((ushort2 >> 8) & 0xFF) + 1));
    Mem_r((ushort)((ushort2 & 0xFF00) | (ushort1 & 0x00FF))); // wrong-page dummy read
    if ((ushort1 & 0xFF00) != (ushort2 & 0xFF00))
        ushort1 = (ushort)((ushort1 & 0xFF) | (byte1 << 8));  // page-cross glitch
    Mem_w(ushort1, byte1);
    break;
```

**LAS/LAR (0xBB)**：read abs,Y 類型，A = X = SP = M & SP：

```csharp
case 0xBB://LAS/LAR abs,Y
    ushort2 = (ushort)(Mem_r(r_PC++) | (Mem_r(r_PC++) << 8));
    ushort1 = (ushort)(ushort2 + r_Y);
    if ((ushort1 & 0xFF00) != (ushort2 & 0xFF00)) // page cross
        Mem_r((ushort)((ushort2 & 0xFF00) | (ushort1 & 0x00FF))); // dummy read
    r_A = r_X = r_SP = (byte)(Mem_r(ushort1) & r_SP);
    if (r_A == 0) flagZ = 1; else flagZ = 0;
    if ((r_A & 0x80) != 0) flagN = 1; else flagN = 0;
    break;
```

### 關於 page-cross glitch

TAS/SHA/SHX/SHY 這類「不穩定」寫入指令有一個特殊的 page-cross 行為：
當 base + index 跨頁時，寫入的高位元組不是 H+1（正常進位），
而是被「AND」上寫入值本身。這意味著跨頁時目標位址的高位元組
會被覆蓋為 `value & (H+1)`，通常導致寫入到較低的記憶體位置。

```
Normal:   base=$10FF, Y=$01 → addr=$1100 (carry to H)
Glitched: base=$10FF, Y=$01, value=$05 → addr=$0500 (H = value & (H+1) = $05 & $11 = $01... 實際取決於匯流排競爭)
```

---

## 修復對應 commit 彙整

| Bug # | Commit | 說明 |
|-------|--------|------|
| 27 | `0fdd934` | abs,X RMW 非官方 opcode wrong-page dummy read (6 個) |
| 28 | `0fdd934` | abs,Y RMW 非官方 opcode wrong-page dummy read (6 個) |
| 29 | `0fdd934` | (ind),Y RMW 非官方 opcode wrong-page dummy read (6 個) |
| 30 | `0fdd934` | SHY/SHX wrong-page dummy read + LAX page-cross dummy read |
| 31 | `0fdd934` | 新增 TAS (0x9B), SHA (0x9F, 0x93), LAS (0xBB) |

---

## 修復對應檔案彙整

| # | 檔案 | 位置 | 修復內容 |
|---|------|------|----------|
| 27 | `CPU.cs` | case 0x1F/3F/5F/7F/DF/FF | 拆分位址計算，加入 wrong-page dummy read |
| 28 | `CPU.cs` | case 0x1B/3B/5B/7B/DB/FB | 拆分位址計算，加入 wrong-page dummy read |
| 29 | `CPU.cs` | case 0x13/33/53/73/D3/F3 | 拆分 indirect 取值，加入 wrong-page dummy read |
| 30 | `CPU.cs` | case 0x9C/9E/BF/B3 | SHY/SHX 加入 dummy read；LAX 加入 page-cross dummy read |
| 31 | `CPU.cs` | 新增 case 0x9B/9F/93/BB | 實作 TAS/SHA/LAS 含正確 dummy read 和 page-cross glitch |

---

## 受影響 opcode 一覽表

共修復 **22 個已有 opcode** 的 dummy read 行為，新增 **4 個 opcode** 實作。

| 類別 | Opcodes | 定址模式 | 修復類型 |
|------|---------|---------|----------|
| SLO | 0x1F, 0x1B, 0x13 | abs,X / abs,Y / (ind),Y | 加入 wrong-page dummy read |
| RLA | 0x3F, 0x3B, 0x33 | abs,X / abs,Y / (ind),Y | 加入 wrong-page dummy read |
| SRE | 0x5F, 0x5B, 0x53 | abs,X / abs,Y / (ind),Y | 加入 wrong-page dummy read |
| RRA | 0x7F, 0x7B, 0x73 | abs,X / abs,Y / (ind),Y | 加入 wrong-page dummy read |
| DCP | 0xDF, 0xDB, 0xD3 | abs,X / abs,Y / (ind),Y | 加入 wrong-page dummy read |
| ISC | 0xFF, 0xFB, 0xF3 | abs,X / abs,Y / (ind),Y | 加入 wrong-page dummy read |
| SHY | 0x9C | abs,X | 加入 wrong-page dummy read |
| SHX | 0x9E | abs,Y | 加入 wrong-page dummy read |
| LAX | 0xBF, 0xB3 | abs,Y / (ind),Y | 加入 page-cross dummy read |
| TAS | 0x9B | abs,Y | **新增實作** |
| SHA | 0x9F, 0x93 | abs,Y / (ind),Y | **新增實作** |
| LAS | 0xBB | abs,Y | **新增實作** |

---

## 測試結果總覽

| 階段 | PASS | FAIL | TOTAL | 主要改善 |
|------|------|------|-------|----------|
| BUGFIX5 後 (f3ab0e8) | 110 | 46 | 156 | Sprite Y+1, MMC1 mirroring |
| **BUGFIX6 (0fdd934)** | **112** | **44** | **156** | CPU dummy reads, 新增 TAS/SHA/LAS |

### 關鍵測試結果變化

| 測試 | 修復前 | 修復後 |
|------|--------|--------|
| instr_misc/04-dummy_reads_apu.nes | FAIL (21 opcode 失敗) | **PASS** |
| instr_misc/instr_misc.nes (merged) | FAIL | **PASS** |

### 剩餘 44 個 FAIL 分析

所有剩餘失敗均為 **timing 相關**（非邏輯錯誤）：

| 類別 | 數量 | 說明 |
|------|------|------|
| APU timing | 10 | frame counter jitter, length timing, IRQ timing, DMC rates |
| PPU VBL/NMI timing | 8 | VBL set/clear time, NMI suppression/on/off timing |
| VBL/NMI timing (standalone) | 6 | vbl_timing, even_odd_frames, nmi_suppression/disable/timing |
| DMC DMA timing | 3 | DMA + $2007/$4016 read interaction |
| CPU interrupt timing | 3 | IRQ + DMA, branch delays IRQ |
| Instruction timing | 2 | unofficial opcode cycle count |
| Sprite timing | 4 | hit timing, overflow timing, SPR DMA + DMC DMA |
| PPU misc timing | 1 | vbl_clear_time |
| Other | 7 | apu_reset timing, sprite overflow obscure, read_joy3 DMC sync |
