# BUGFIX18: CPU Interrupt Timing — penultimate-cycle IRQ + NMI deferral + DMA alignment

**日期**: 2026-02-22
**基線**: 165 PASS / 9 FAIL → **169 PASS / 5 FAIL** (+4 PASS)

## 問題

- `cpu_interrupts_v2/2-nmi_and_brk` — rows 9-10: NMI fires before SEC instead of after
- `cpu_interrupts_v2/4-irq_and_dma` — IRQ after DMA fires at wrong instruction
- `cpu_interrupts_v2/5-branch_delays_irq` — test_jmp baseline fails (3-cycle JMP penultimate wrong)
- `cpu_interrupts_v2/cpu_interrupts` — merged test (因 sub-test 2,4,5 失敗)

## 根因

### 1. irqLineAtFetch 對 3+ cycle 指令偏早 (tests 4, 5)

`irqLineAtFetch` 在 opcode fetch 的 tick 後取樣 IRQ line state。對 2-cycle 指令正確（tick 1 = penultimate），但對 3-cycle JMP（penultimate = tick 2）和 OAM DMA（517 ticks, penultimate = tick 516）都偏早。

### 2. BRK/IRQ/NMI sequence 後 NMI 提前觸發 (test 2)

NMI edge 在 BRK cycles 6-7 期間 → nmi_delay → promote → nmi_pending → run() 直接觸發 NMI（在 IRQ handler 的 SEC 之前）。真實 NES: interrupt sequence 不做 NMI polling，NMI 在 handler 第一條指令才觸發。

### 3. Branch taken-no-cross IRQ 偵測錯誤 (test 5)

Taken branch 無 page cross 有 3 個 tick，但 penultimate 應為 tick 1（不是 tick 2）。tick 3（extra tick）不參與 IRQ polling。

### 4. OAM DMA 後 IRQ timing 偏移 (test 4)

DMA 期間 tick() 持續更新 irqLinePrev/irqLineCurrent，導致 DMA 後 irqLinePrev 反映 DMA 末尾狀態而非 DMA 前狀態。另外 DMA 缺少 alignment cycle（513 → 514 ticks）。

## 修復

### Fix 1: irqLinePrev/irqLineCurrent per-tick tracking (MEM.cs)

在 tick() 末尾追蹤 IRQ line 前一次/當前狀態。指令結束後 irqLinePrev 自然持有 penultimate tick 的 IRQ state，適用於所有指令長度。

```csharp
// tick() 末尾
irqLinePrev = irqLineCurrent;
irqLineCurrent = statusframeint || statusdmcint || statusmapperint;
```

### Fix 2: NMI deferral after interrupt sequences (Main.cs)

新增 `nmi_just_deferred` flag。BRK/IRQ/NMI interrupt sequence 完成後若 nmi_pending 被設定，延遲 1 條指令再觸發 NMI。

### Fix 3: Branch irqLinePrev save/restore (CPU.cs)

8 個 branch 指令中，taken 時先保存 irqLinePrev，若無 page cross 則恢復（extra tick 不影響 IRQ polling）。

### Fix 4: OAM DMA isolation + alignment (PPU.cs)

- DMA 前保存 irqLinePrev，DMA 後恢復
- 新增 alignment tick（1 halt + 1 align + 256×2 R/W = 514 ticks）

### Fix 5: 清理

- 移除 `irqLineAtFetch`（CPU.cs）
- 移除 `oam_dma_occurred`（PPU.cs + Main.cs）
- 移除 `branch_taken_no_cross`（CPU.cs + Main.cs）

## 修改檔案

| 檔案 | 改動 |
|------|------|
| `NesCore/MEM.cs` | tick() 末尾加 irqLinePrev/irqLineCurrent tracking |
| `NesCore/CPU.cs` | 移除 irqLineAtFetch/branch_taken_no_cross，加 branch irqLinePrev save/restore |
| `NesCore/PPU.cs` | 移除 oam_dma_occurred，加 DMA irqLinePrev isolation + alignment tick |
| `NesCore/Main.cs` | 重構 run()：NMI deferral + irqLinePrev IRQ poll |

## 驗證

```
=== FINAL RESULTS ===
PASS: 169 / TOTAL: 174 / FAIL: 5

cpu_interrupts_v2 全部通過:
- 1-cli_latency: PASS
- 2-nmi_and_brk: PASS ← NEW
- 3-nmi_and_irq: PASS
- 4-irq_and_dma: PASS ← NEW
- 5-branch_delays_irq: PASS ← NEW
- cpu_interrupts (merged): PASS ← NEW

零回歸:
- ppu_vbl_nmi: 10/10 PASS
- vbl_nmi_timing: 7/7 PASS
- blargg_apu_2005: 11/11 PASS
- sprite tests: 16/16 PASS
- mmc3 tests: 18/18 PASS

剩餘 5 FAIL（全為 Bug F — DMC DMA cycle stealing）:
- dmc_dma_during_read4: 3 FAIL
- sprdma_and_dmc_dma: 2 FAIL
```
