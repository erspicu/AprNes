# AprNes Bug 修復紀錄（第九輯）

本文件接續 `BUGFIX8.md`（Bug 33），記錄 Bug 34。

---

## 目錄

34. [APU Frame Counter Timing：frameReload 偏移修正、IRQ 三連 assert、even/odd jitter](#34-apu-frame-counter-timingframereload-偏移修正irq-三連-assertevenodd-jitter)

---

## 34. APU Frame Counter Timing：frameReload 偏移修正、IRQ 三連 assert、even/odd jitter

### 現象

128 PASS / 46 FAIL。以下 7 個 APU timing 測試全部 FAIL，錯誤訊息皆為 "too late"：

| 測試 ROM | 錯誤 |
|----------|------|
| apu_test/4-jitter | too late |
| apu_test/5-len_timing | too late |
| apu_test/6-irq_flag_timing | too late |
| blargg_apu_2005/04.clock_jitter | too late |
| blargg_apu_2005/05.len_timing_mode0 | too late |
| blargg_apu_2005/06.len_timing_mode1 | too late |
| blargg_apu_2005/07.irq_flag_timing | too late |

### 根本原因

三個問題疊加導致 frame counter 事件全部延遲：

1. **$4017 write offset +7 過大**：應為 +2（加上 even/odd jitter）
2. **frameReload4[0] 少 1 cycle**：7457 應為 7458
3. **缺少 IRQ pre-fire 與 post-fire**：真實 NES 的 mode 0 IRQ flag 在 step 3 前後各 1 cycle 都會 assert（共 3 個連續 cycle）

### 修復方式

#### 1. APU.cs — 更新 frameReload 常數

```csharp
// 舊:
static int[] frameReload4 = { 7457, 7456, 7458, 7458 };
static int[] frameReload5 = { 7457, 7456, 7458, 7458, 7453 };
static int framectrdiv = 7457;

// 新:
static int[] frameReload4 = { 7458, 7456, 7458, 7458 };
static int[] frameReload5 = { 7458, 7456, 7458, 7458, 7452 };
static int framectrdiv = 7458;
```

#### 2. IO.cs — $4017 write offset + even/odd jitter

```csharp
// 舊:
framectrdiv = frameReload5[0] + 7;
framectrdiv = frameReload4[0] + 7;

// 新:
int jitter = 2 + (apucycle & 1); // even/odd CPU cycle jitter
framectrdiv = frameReload5[0] + jitter;
framectrdiv = frameReload4[0] + jitter;
```

NES 硬體在 $4017 寫入時，根據 CPU cycle 的 even/odd 對齊產生 ±1 cycle jitter。

#### 3. APU.cs — IRQ pre-fire（step 3 前 1 cycle）

```csharp
// 在 apu_step() 的 frame counter decrement 之前：
if (framectrdiv == 2 && framectr == 3 && ctrmode == 4 && !apuintflag)
    statusframeint = true;
```

`framectrdiv == 2` 表示下一次 decrement 後為 1（不觸發 step），再下一次才觸發 step 3。
因此 pre-fire 發生在 step 3 前 1 cycle。

#### 4. APU.cs — IRQ post-fire（step 3 後 1 cycle）

新增 `irqAssertCycles` 倒數計數器：

```csharp
static int irqAssertCycles = 0;

// apu_step() 開頭（frame counter decrement 之前）：
if (irqAssertCycles > 0 && !apuintflag)
{
    statusframeint = true;
    --irqAssertCycles;
}

// clockframecounter() 中 step 3 觸發時：
if (!apuintflag && framectr == 3 && ctrmode == 4)
{
    statusframeint = true;
    irqAssertCycles = 1; // 下一 cycle 再 assert 一次
}
```

三連 assert 結果：cycle 29831 (pre-fire) → 29832 (step 3) → 29833 (post-fire)。
blargg 6-irq_flag_timing 的 test 4 驗證：讀 $4015 於 29832 清除 flag 後，
第二次讀仍可見 flag（因 post-fire 在 29833 重新 assert）。

#### 5. APU.cs — 移除 !statusframeint guard

```csharp
// 舊: if (!apuintflag && framectr == 3 && ctrmode == 4 && !statusframeint)
// 新: if (!apuintflag && framectr == 3 && ctrmode == 4)
```

允許 flag 在被 $4015 read 清除後重新 assert。

### Mode 0 時序驗證（從 $4017 write, even cycle）

```
Pre-fire:  7460 + 7456 + 7458 + 7458 - 1 = 29831  ← flag first set ✓
Step 3:    7460 + 7456 + 7458 + 7458     = 29832  ← flag re-set, length ✓
Post-fire: 29833                                    ← flag re-set ✓
```

### 涉及檔案

| 檔案 | 改動摘要 |
|------|---------|
| `NesCore/APU.cs` | frameReload 陣列修正、framectrdiv 初始值、IRQ pre/post-fire、移除 guard |
| `NesCore/IO.cs` | $4017 offset +7→+2 + even/odd jitter |

### 測試結果

| 指標 | 修復前 | 修復後 |
|------|--------|--------|
| PASS | 128 | 134 |
| FAIL | 46 | 40 |
| TOTAL | 174 | 174 |
| **改善** | — | **+6 PASS, 0 退化** |

#### 新通過的 7 個 ROM

| ROM | 修復原因 |
|-----|---------|
| apu_test/4-jitter | even/odd jitter 正確處理 |
| apu_test/5-len_timing | frameReload[0] 修正 + offset 修正 |
| apu_test/6-irq_flag_timing | IRQ 三連 assert (pre/step3/post) |
| blargg_apu_2005/04.clock_jitter | even/odd jitter |
| blargg_apu_2005/05.len_timing_mode0 | length counter timing 正確 |
| blargg_apu_2005/06.len_timing_mode1 | mode 1 timing 正確 |
| blargg_apu_2005/07.irq_flag_timing | IRQ flag timing 正確 |

#### 仍然失敗的 APU 測試（已知）

| ROM | 原因 |
|-----|------|
| apu_test/8-dmc_rates | DMC rate timer 週期問題，與 frame counter 無關 |
| apu_test/apu_test (combined) | 因 test 8 失敗而整體 FAIL |
| blargg_apu_2005/08.irq_timing | IRQ 實際觸發 timing（需 IRQ handler delay 精確模擬） |
| blargg_apu_2005/09.reset_timing | 軟重置後 frame counter 行為 |
| blargg_apu_2005/10.len_halt_timing | length counter halt 精確時序 |
| blargg_apu_2005/11.len_reload_timing | length counter reload 精確時序 |

---

*最後更新: 2026-02-21*
