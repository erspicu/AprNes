# AprNes Bug 修復紀錄（第十一輯）

本文件接續 `BUGFIX10.md`（Bug 35），記錄 Bug 36。

---

## 目錄

36. [APU Power-on/Reset Advance + Length Counter Reload Suppression](#36-apu-power-onreset-advance--length-counter-reload-suppression)

---

## 36. APU Power-on/Reset Advance + Length Counter Reload Suppression

### 現象

136 PASS / 38 FAIL。APU power-on/reset 和 length counter 相關測試失敗：

| 測試 ROM | 錯誤 |
|----------|------|
| apu_reset/4017_timing | "Frame IRQ flag should be set sooner after power/reset" (#3) |
| apu_reset/4017_written | "At power, $4017 should be written with $00" (#2) |
| blargg_apu_2005/09.reset_timing | Reset 後 timing ($04) |

### 根本原因

#### 1. Power-on/Reset Advance 缺失

真實 NES 在 power-on 和 reset 時，相當於在第一條指令執行前 9-12 個 CPU cycle 就寫入了 `$4017 = $00`。這意味著 frame counter 在 CPU 開始執行時已經提前走了幾個 cycle。

模擬器的 `initAPU()` 和 `apuSoftReset()` 在 reset vector 讀取完成後才被呼叫，且 `framectrdiv` 設為初始值 7458，沒有模擬這個提前量。

- `initAPU()` 在 Main.cs 的 power-on sequence 中，`in_tick = true` 跳過了 reset vector 讀取期間的 APU ticking
- `apuSoftReset()` 在 CPU.cs 的 `ResetInterrupt()` 尾部呼叫，前面的 7 個 `Mem_r` 已經 tick 了 APU，但 `apuSoftReset()` 把 `framectrdiv` 重設為 7458，抹掉了那些 tick

#### 2. Length Counter Reload Suppression 缺失

真實 NES 的 length counter 在 length clock（half-frame）同一 cycle 寫入 `$4003/$4007/$400B/$400F` 時，若 counter > 0，reload 會被抑制。模擬器缺少此機制。

### 修復方式

#### 1. APU.cs — initAPU() power-on advance

```csharp
// 舊:
framectrdiv = 7458;

// 新:
framectrdiv = 7450; // 7458 + 2(even jitter) - 10(power-on advance ≈ 9-12 clocks)
```

#### 2. APU.cs — apuSoftReset() reset advance

```csharp
// 舊:
framectrdiv = 7458;

// 新:
framectrdiv = 7450; // match power-on advance
```

#### 3. APU.cs — lengthClockThisCycle flag 機制

新增 flag 陣列：
```csharp
static bool[] lengthClockThisCycle = { false, false, false, false };
```

在 `apu_step()` 每 cycle 開頭清除，在 `setlength()` 中 decrement 時設定：
```csharp
// apu_step():
lengthClockThisCycle[0] = lengthClockThisCycle[1] =
lengthClockThisCycle[2] = lengthClockThisCycle[3] = false;

// setlength():
if (!lenctrHalt[i] && lengthctr[i] > 0)
{
    --lengthctr[i];
    lengthClockThisCycle[i] = true;
    ...
}
```

#### 4. APU.cs — apu_4003/4007/400B/400F reload suppression

```csharp
// 舊:
if (lenCtrEnable[ch])
    lengthctr[ch] = lenctrload[(val >> 3) & 0x1F];

// 新:
if (lenCtrEnable[ch] && !(lengthClockThisCycle[ch] && lengthctr[ch] > 0))
    lengthctr[ch] = lenctrload[(val >> 3) & 0x1F];
```

### 時序驗證

**4017_timing**（power-on advance test）:
- framectrdiv = 7450 → first IRQ at ~29822
- 測試迴圈每 ~29831 cycles 讀 $4015 → IRQ 在窗口內 → PASS ✓

**4017_written**（power-on $4017=$00 test）:
- framectrdiv = 7450 → step 1 at 7450 + 7456 = 14906
- 測試在 ~14914 讀 $4015 → length 已被 clock → PASS ✓

**09.reset_timing**:
- apuSoftReset 設 framectrdiv = 7450 → 時序提前 8 cycles
- 測試讀 $4015 時 flag 已在窗口內 → PASS ✓

### 涉及檔案

| 檔案 | 改動摘要 |
|------|---------:|
| `NesCore/APU.cs` | initAPU/apuSoftReset framectrdiv 7458→7450，新增 lengthClockThisCycle flag，setlength 設定 flag，apu_step 清除 flag，4 個 register handler 加入 reload suppression |

### 測試結果

| 指標 | 修復前 | 修復後 |
|------|--------|--------|
| PASS | 136 | 139 |
| FAIL | 38 | 35 |
| TOTAL | 174 | 174 |
| **改善** | — | **+3 PASS, 0 退化** |

#### 新通過的 3 個 ROM

| ROM | 修復原因 |
|-----|---------:|
| apu_reset/4017_timing | Power-on advance (framectrdiv=7450) |
| apu_reset/4017_written | Power-on advance (framectrdiv=7450) |
| blargg_apu_2005/09.reset_timing | Reset advance (apuSoftReset framectrdiv=7450) |

#### 部分改善（未轉 PASS）

| ROM | 變化 |
|-----|------|
| blargg_apu_2005/11.len_reload_timing | $04→$03（test 4 修復，test 3 新露出） |

#### 仍待修復（已延後）

| ROM | 原因 |
|-----|------|
| blargg_apu_2005/08.irq_timing | 需 IRQ line/flag 分離 + penultimate-cycle polling |
| blargg_apu_2005/10.len_halt_timing | 需更精確的 halt timing 行為 |
| blargg_apu_2005/11.len_reload_timing | test 3 需要進一步分析 |

---

*最後更新: 2026-02-22*
