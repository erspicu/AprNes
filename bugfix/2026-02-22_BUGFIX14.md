# BUGFIX14: APU IRQ Timing + CPU IRQ Polling (Bug D Remaining + Bug E Partial)

**Date**: 2026-02-22
**Result**: 156 PASS → 160 PASS (+4), 18 FAIL → 14 FAIL

## Fixed Tests
- `blargg_apu_2005/08.irq_timing` — Frame IRQ fires at correct cycle (was $02 "too soon")
- `blargg_apu_2005/10.len_halt_timing` — Length counter halt timing visible via $4015
- `blargg_apu_2005/11.len_reload_timing` — Length counter reload timing visible via $4015
- `cpu_interrupts_v2/3-nmi_and_irq` — NMI + IRQ priority interaction (bonus fix)

## Root Cause

Three separate timing issues in the APU frame counter and CPU IRQ detection:

### Issue 1: IRQ pre-fire mechanism was incorrect
The previous implementation set `statusframeint` 2 cycles before step 3 via a
"pre-fire" check (`framectrdiv == 2 && framectr == 3`). This created a 3-cycle
assert pattern (pre-fire, step 3, post-fire) that didn't match hardware behavior.

On real hardware, the frame IRQ flag is asserted starting at step 3 and continues
for 2 additional cycles after, creating a 3-cycle window: {step3, step3+1, step3+2}.

**Fix**: Removed pre-fire. Changed `irqAssertCycles = 1` to `irqAssertCycles = 2`
so clockframecounter sets the flag at step 3, then the post-fire loop asserts it
for 2 more cycles.

### Issue 2: $4015 reads showed post-step length counter values
The length counter is clocked during frame counter steps. When a test reads $4015
on the same cycle as a length counter step, it should see the pre-step value
(before the clock). Our emulator's `tick()` runs `apu_step()` before the CPU
read completes, so by the time $4015 is read, the length counter has already
been decremented.

**Fix**: Added `lengthctr_snapshot[]` array. At the start of each `apu_step()`,
snapshot the current length counter values before any frame counter processing.
`apu_r_4015()` reads from the snapshot instead of the live values.

### Issue 3: CPU IRQ detection timing (critical for 08.irq_timing)
The 08.irq_timing test runs two phases that differ by 1 cycle. It expects the
frame IRQ to be detected during `lda #0` (A=0 → pass) for both phases, not
during the preceding `nop` (A=2 → "too soon") or following `lda #3` (A=3 →
"too late").

The problem: when step 3 fires during the last cycle of `nop`, the IRQ flag
becomes true during that tick. Our emulator polls IRQ at the instruction boundary
(after the last cycle), so the IRQ was detected immediately after `nop` — one
instruction too early.

On real NES hardware, the CPU samples the IRQ line at the **penultimate cycle**
of each instruction. For 2-cycle instructions (like `nop` and `lda #`), the
penultimate cycle is the first cycle (opcode fetch). If the IRQ flag changes
during the last cycle, it's not detected until the next instruction's
penultimate cycle.

**Fix**: Added `irqLineAtFetch` — captures the IRQ line state right after the
opcode fetch tick. The IRQ poll at the instruction boundary uses this sampled
value instead of the current flag state. This models penultimate-cycle polling
for 2-cycle instructions.

### Issue 4: Branch IRQ suppression + OAM DMA IRQ deferral
On real hardware, a taken branch without page crossing suppresses the IRQ poll
at the end of the instruction. Similarly, during OAM DMA ($4014 write), the
CPU doesn't poll IRQ until the DMA completes.

**Fix**: Added `branch_taken_no_cross` flag set in all 8 branch instructions,
and `oam_dma_occurred` flag set in `ppu_w_4014()`. Both suppress IRQ polling
in the main loop. This combined with `irqLineAtFetch` fixed `3-nmi_and_irq`.

## Changes

### APU.cs
1. Added `lengthctr_snapshot[]` array — snapshot at start of `apu_step()`
2. Removed pre-fire: deleted `if (framectrdiv == 2 && framectr == 3 ...)`
3. Changed `irqAssertCycles = 1` → `irqAssertCycles = 2` in `clockframecounter()`
4. `apu_r_4015()` reads `lengthctr_snapshot` instead of `lengthctr`
5. Init/reset: `framectrdiv = 7449` (tick-before-write compensation)

### IO.cs
6. `framectrdiv = frameReload[0] + jitter - 1` (tick-before-write compensation)

### CPU.cs
7. Added `irqLineAtFetch` field — sampled after opcode fetch
8. Added `branch_taken_no_cross` field — set in 8 branch instructions (BCC/BCS/BEQ/BMI/BNE/BPL/BVC/BVS)

### PPU.cs
9. Added `oam_dma_occurred` field — set in `ppu_w_4014()`

### Main.cs
10. IRQ poll uses `irqLineAtFetch` instead of direct flag check
11. IRQ poll suppressed when `branch_taken_no_cross || oam_dma_occurred`
12. Both flags reset before each `cpu_step()`

## Verification
- blargg_apu_2005: **11/11 PASS** (was 8/11)
- cpu_interrupts_v2: **2/5 PASS** (was 1/5)
- Full test suite: 158 PASS / 16 FAIL / 174 TOTAL (run_tests_report.sh)
  - 16 FAIL 含 2 個重複: cpu_interrupts merged + mmc3_test_2/4-scanline_timing
- Zero regressions on all previously passing tests
