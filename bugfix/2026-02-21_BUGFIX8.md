# AprNes Bug 修復紀錄（第八輯）

本文件接續 `BUGFIX7.md`（Bug 32），記錄 commit 修復的 Bug 33。
所有修復均已 commit 至 master 分支。

---

## 目錄

33. [MMC3 IRQ A12 Clocking：從 hardcoded cycle 260 改為 PPU address bus A12 rising edge 驅動](#33-mmc3-irq-a12-clocking從-hardcoded-cycle-260-改為-ppu-address-bus-a12-rising-edge-驅動)

---

## 33. MMC3 IRQ A12 Clocking：從 hardcoded cycle 260 改為 PPU address bus A12 rising edge 驅動

### 現象

174 個測試 ROM 中有 16 個 MMC3 測試 FAIL（17 個 MMC3 測試中僅 1 個通過）。
主要錯誤訊息：

- "Should decrement when A12 is toggled via $2006"
- "A12 clocking" 系列全部失敗
- "MMC3 rev B" 行為不正確

### 根本原因

MMC3 (Mapper 004) 的 IRQ counter 應由 PPU address bus **A12 (bit 12) 的 rising edge** 觸發。
真實硬體上，以下事件都會在 PPU address bus 上產生 A12 變化：

1. **BG tile fetch** (cycles 0-255, 320-335)：NT/AT fetch → A12=0，pattern fetch → A12=BgPatternTableAddr bit 12
2. **Sprite tile fetch** (cycles 256-319)：dummy NT fetch → A12=0，sprite pattern fetch → A12=SpPatternTableAddr bit 12
3. **$2006 (PPUADDR) 寫入**：CPU 設定 vram_addr，A12 隨之變化
4. **$2007 (PPUDATA) 讀寫**：vram_addr increment 後 A12 可能變化
5. **Pre-render scanline** (261) vert copy：vram_addr 被 vram_addr_internal 覆蓋

原實作**只在 cycle 260 hardcoded 呼叫一次** `Mapper04step_IRQ()`，完全不追蹤 A12 狀態，
因此 $2006/$2007 手動觸發 A12 變化無法 clock IRQ counter，且 scanline timing 也不正確。

### 修復方式

#### 1. Mapper004.cs — 新增 A12 追蹤與 low-pass filter

```csharp
// 新增欄位
int lastA12 = 0;
int a12LowSince = -100;  // PPU absolute cycle when A12 last went low
const int A12_FILTER = 16;

// 新增方法
public void NotifyA12(int address, int ppuAbsCycle)
{
    int a12 = (address >> 12) & 1;
    if (a12 != 0 && lastA12 == 0)
    {
        // Rising edge 0→1: clock IRQ counter if A12 was low long enough
        int elapsed = ppuAbsCycle - a12LowSince;
        if (elapsed < 0) elapsed += 341 * 262;
        if (elapsed >= A12_FILTER)
            Mapper04step_IRQ();
    }
    else if (a12 == 0 && lastA12 != 0)
    {
        // Falling edge 1→0: record when A12 went low
        a12LowSince = ppuAbsCycle;
    }
    lastA12 = a12;
}
```

Low-pass filter 用途：真實 MMC3 硬體有內建 filter，忽略過短（<16 PPU cycles）的
A12 脈衝。這避免了 BG tile fetch 期間 NT/pattern 之間快速切換產生的假 clock。

#### 2. PPU.cs — 新增 NotifyMapperA12() helper

```csharp
[MethodImpl(MethodImplOptions.AggressiveInlining)]
static void NotifyMapperA12(int address)
{
    ((Mapper004)MapperObj).NotifyA12(address, scanline * 341 + ppu_cycles_x);
}
```

#### 3. PPU.cs — BG tile fetch 通知 A12

在 `ppu_rendering_tick()` 的 case 0/2/4/6，ioaddr 設定後各加一行：
```csharp
if (mapper == 4) NotifyMapperA12(ioaddr);
```

case 0/2 為 NT/AT fetch (address 0x2000+，A12=0)，
case 4/6 為 pattern fetch (address 隨 BgPatternTableAddr 決定 A12)。

#### 4. PPU.cs — Sprite fetch 模擬 A12

cycles 260-319，每 8 cycle 模擬 dummy NT fetch + sprite pattern fetch：
```csharp
else if (ppu_cycles_x >= 260 && ppu_cycles_x < 320 && mapper == 4)
{
    int phase = (ppu_cycles_x - 256) & 7;
    if (phase == 0) NotifyMapperA12(0x2000);                // dummy NT, A12=0
    else if (phase == 4) NotifyMapperA12(SpPatternTableAddr); // sprite CHR fetch
}
```

#### 5. PPU.cs — 移除 hardcoded cycle 260

移除兩處 hardcoded 呼叫：
- visible scanlines (0-239) cycle 260 的 `Mapper04step_IRQ()`
- pre-render scanline (261) cycle 260 的 `Mapper04step_IRQ()`

#### 6. PPU.cs — $2006 second write 通知

在 `ppu_w_2006()` 的 `vram_addr = vram_addr_internal;` 後：
```csharp
if (mapper == 4) NotifyMapperA12(vram_addr);
```

#### 7. PPU.cs — Pre-render vert copy 通知

在 scanline 261 / cycles 280-304 的 vram_addr copy 後：
```csharp
if (mapper == 4) NotifyMapperA12(vram_addr);
```

#### 8. MEM.cs — $2007 read/write 後通知

在 `ppu_read_fun` (5 處) 和 `ppu_write_fun` (3 處) 的所有 lambda 中，
`vram_addr` increment 後各加一行：
```csharp
if (mapper == 4) NotifyMapperA12(vram_addr);
```

### 涉及檔案

| 檔案 | 改動摘要 |
|------|---------|
| `NesCore/Mapper/Mapper004.cs` | +A12 追蹤欄位 + `NotifyA12()` 方法 |
| `NesCore/PPU.cs` | +`NotifyMapperA12()` helper；BG fetch/sprite fetch/vert copy 通知；移除 hardcoded cycle 260；$2006 通知 |
| `NesCore/MEM.cs` | $2007 read (5 處) + write (3 處) 的 vram_addr increment 後通知 A12 |

### 測試結果

| 指標 | 修復前 | 修復後 |
|------|--------|--------|
| PASS | 113 | 125 |
| FAIL | 61 | 49 |
| TOTAL | 174 | 174 |
| **改善** | — | **+12 PASS, 0 退化** |

#### 新通過的 12 個 ROM

| ROM | 修復原因 |
|-----|---------|
| mmc3_irq_tests/1.Clocking | A12 rising edge 驅動 IRQ counter |
| mmc3_irq_tests/2.Details | counter reload/decrement 行為正確 |
| mmc3_irq_tests/3.A12_clocking | $2006 手動 A12 toggle 可 clock counter |
| mmc3_irq_tests/6.MMC3_rev_B | Rev B reload 行為正確 |
| mmc3_test/1-clocking | A12 驅動 clocking 正確 |
| mmc3_test/2-details | counter 細節正確 |
| mmc3_test/3-A12_clocking | $2006 A12 clocking 正確 |
| mmc3_test/5-MMC3 | MMC3 整體行為正確 |
| mmc3_test_2/rom_singles/1-clocking | 同 mmc3_test 系列 |
| mmc3_test_2/rom_singles/2-details | 同上 |
| mmc3_test_2/rom_singles/3-A12_clocking | 同上 |
| mmc3_test_2/rom_singles/5-MMC3 | 同上 |

#### 仍然失敗的 5 個 MMC3 ROM（預期中）

| ROM | 原因 |
|-----|------|
| mmc3_irq_tests/5.MMC3_rev_A | 我們實作 Rev B 行為，Rev A counter reload 邏輯不同 |
| mmc3_test/4-scanline_timing | sprite fetch A12 timing 微調仍需精進 |
| mmc3_test/6-MMC6 | MMC6 是不同晶片，需要獨立實作 |
| mmc3_test_2/rom_singles/4-scanline_timing | 同 mmc3_test/4 |
| mmc3_test_2/rom_singles/6-MMC3_alt | MMC3 alternate 行為（可能是 Rev A） |

---

*最後更新: 2026-02-21*
