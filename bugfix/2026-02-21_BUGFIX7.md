# AprNes Bug 修復紀錄（第七輯）

本文件接續 `BUGFIX6.md`（Bug 27–31），記錄 commit 修復的 Bug 32。
所有修復均已 commit 至 master 分支。

---

## 目錄

32. [MMC3 (Mapper 004) IRQ 在 tick-on-access 架構下直接呼叫 IRQInterrupt 導致畫面損壞](#32-mmc3-mapper-004-irq-在-tick-on-access-架構下直接呼叫-irqinterrupt-導致畫面損壞)

---

## 32. MMC3 (Mapper 004) IRQ 在 tick-on-access 架構下直接呼叫 IRQInterrupt 導致畫面損壞

### 現象

Super Mario Bros 3（Mapper 004/MMC3）畫面嚴重損壞。此問題在 CPU tick-on-access
cycle-accurate 架構轉換後出現。

### 根本原因

Mapper004 的 `Mapper04step_IRQ()` 在 PPU A12 rising edge 時（`ppu_step_new()` 內
cycle 260 處）直接呼叫 `NesCore.IRQInterrupt()`。

在舊架構中，`IRQInterrupt()` 只是設定暫存器狀態（push stack、設定 PC），以
`Interrupt_cycle = 7` 事後追補 cycle。雖然從 PPU step 內同步呼叫仍不正確，但
因為沒有實際 bus 操作，副作用較小。

新 tick-on-access 架構中，`IRQInterrupt()` 改為 7 次真實的 `Mem_r`/`Mem_w`
呼叫（每次都會觸發 `tick()`）。從 PPU step 內呼叫會造成兩個嚴重問題：

1. **CPU 狀態在指令執行途中被竄改**：某條 CPU 指令正在執行 `Mem_r(addr)` →
   `tick()` → `ppu_step_new()` → `Mapper04step_IRQ()` → `IRQInterrupt()` 修改了
   `r_PC` 和 `r_SP`，但原指令仍在執行中，導致 CPU 狀態完全錯亂。

2. **7 個 PPU/APU tick 被吞掉**：`tick()` 中的 `in_tick` 防遞迴保護機制會
   阻擋 `IRQInterrupt()` 內 7 次 `Mem_r`/`Mem_w` 的巢狀 `tick()` 呼叫，
   造成 7 個 CPU cycle 的 PPU/APU 推進完全遺失。

### 呼叫鏈分析

```
CPU 指令執行
  └→ Mem_r(addr)
       └→ tick()                    ← in_tick = true
            └→ ppu_step_new() ×3
                 └→ (cycle 260) Mapper04step_IRQ()
                      └→ IRQInterrupt()          ← 直接修改 PC/SP！
                           └→ Mem_r(r_PC)        ← tick() 被 in_tick 擋住
                           └→ Mem_w(stack)        ← tick() 被 in_tick 擋住
                           └→ ... (共7次)
            └→ apu_step()
       └→ mem_read_fun[addr]        ← 但 PC/SP 已被改壞
```

### 修復方式

改為正確的硬體行為：mapper 只 assert /IRQ 線，CPU 在指令邊界輪詢 IRQ 來源。

#### 1. CPU.cs — 新增 mapper IRQ flag

```csharp
static public bool statusmapperint = false; // mapper IRQ line asserted (MMC3 etc.)
```

移除不再需要的 `FlagI_public`（原本只供 mapper 檢查 I flag 用）。

reset 時一併清除：
```csharp
statusmapperint = false;
```

#### 2. Mapper004.cs — 設 flag 取代直接呼叫

```csharp
// 修改前
if (IRQCounter == 0 && IRQ_enable && NesCore.FlagI_public == 0)
    NesCore.IRQInterrupt();

// 修改後
if (IRQCounter == 0 && IRQ_enable)
    NesCore.statusmapperint = true; // assert /IRQ line, polled at instruction boundary
```

同時移除 `FlagI_public == 0` 檢查：在真實硬體中，mapper 不關心 CPU 的 I flag，
它只負責 assert /IRQ 線。CPU 在指令邊界自行決定是否 service IRQ（根據 I flag）。

$E000 even 寫入時 acknowledge（de-assert /IRQ）：
```csharp
// 修改前
IRQ_enable = false;

// 修改後
IRQ_enable = false;
NesCore.statusmapperint = false; // acknowledge: de-assert /IRQ line
```

#### 3. Main.cs — IRQ 輪詢加入 mapper 來源

```csharp
// 修改前
irq_pending = (irqPollI == 0 && (statusframeint || statusdmcint));

// 修改後
irq_pending = (irqPollI == 0 && (statusframeint || statusdmcint || statusmapperint));
```

### 其他 Mapper 檢查結果

| Mapper | 名稱 | IRQ | 架構相容性 |
|--------|------|-----|-----------|
| 000 | NROM | 無 | OK |
| 001 | MMC1 | 無 | OK |
| 002 | UxROM | 無 | OK |
| 003 | CNROM | 無 | OK |
| **004** | **MMC3** | **有** | **已修復** |
| 005 | MMC5 | Stub (未實作) | OK |
| 007 | AxROM | 無 | OK |
| 011 | Color Dreams | 無 | OK |
| 066 | GxROM | 無 | OK |
| 071 | Camerica | 無 | OK |

Mapper 004 是唯一有 IRQ 且直接呼叫 `IRQInterrupt()` 的 mapper，其餘均為
純 bank-switching，與 tick-on-access 架構完全相容。

### 測試結果

修復前：SM3 畫面嚴重損壞
修復後：112 PASS / 44 FAIL / 156 TOTAL（無退化）
