# BUGFIX13: MMC3 Scanline Timing (Bug M)

**Date**: 2026-02-22
**Result**: 154 PASS → 156 PASS (+2), 20 FAIL → 18 FAIL

## Fixed Tests
- `mmc3_test/4-scanline_timing` — all 14 sub-tests PASS
- `mmc3_test_2/rom_singles/4-scanline_timing` — all 14 sub-tests PASS

## Root Cause

MMC3 IRQ timing depends on PPU A12 rising edges during tile fetches. The test
measures the exact PPU cycle where the IRQ fires for two configurations:
- `$2000=$08` (BG=$0000, Sp=$1000): first valid A12 clock at sprite CHR fetch
- `$2000=$10` (BG=$1000, Sp=$0000): first valid A12 clock at BG CHR fetch
- Expected difference: exactly 256 PPU cycles

Three issues caused incorrect timing:

### Issue 1: BG A12 notification phase offset
BG tile fetch A12 notifications were at phases 0,2,4,6 (address setup cycles).
On the real NES, the bus timing means the effective A12 transitions are shifted
by +3 cycles relative to our PPU cycle base. Moving notifications to phases 3,7
(AT data read and CHR high data read) aligns BG CHR A12 to cx=7 instead of cx=4.

### Issue 2: Missing garbage NT fetches
The real NES PPU performs two garbage nametable fetches at dots 337-340 at the
end of each scanline. These put A12=0 on the bus, creating the falling edge
needed before the next scanline's BG CHR rising edge. Without this, the 16-cycle
A12 filter couldn't distinguish scanline boundaries from intra-tile transitions.

### Issue 3: VBL gap corrupting A12 filter state
Between test iterations, rendering is disabled during VBL. The mapper's `lastA12`
retained its value from the previous test's rendering. If `lastA12=1` at the
start of the pre-render scanline, the first BG notification (A12=0 at phase 3)
created a fresh falling edge, resetting `a12LowSince`. The subsequent rising
edge at cx=7 (only 4 cycles later) was then filtered by the 16-cycle threshold.

On real hardware, A12 was already 0 from the previous frame's garbage NT fetches
through VBL, so no fresh falling edge occurred.

## Changes

### PPU.cs — `ppu_rendering_tick()`

1. **BG A12 notifications: phases 0,2,4,6 → phases 3,7**
   - Phase 3 (AT data read): notifies with AT address (A12=0, falling edge point)
   - Phase 7 (CHR high data read): notifies with CHR address (A12=BG table bit12)
   - BG CHR A12 now at cx=7 (was cx=4), giving 263-7=256 PPU cycle difference

2. **Sprite fetch range: cx≥260 → cx≥257**
   - Merged CopyHoriV into sprite fetch branch
   - Phase base changed from 256 to 257
   - Sprite A12 at phases 2,6 (garbage NT at cx=259, CHR at cx=263)

3. **Garbage NT notification at cx=337**
   - Sends A12=0 (nametable address) at dot 337
   - Creates falling edge after BG prefetch CHR (A12=1 for BG=$1000)

4. **Removed incorrect A12 from vert(v) copy** (pre-render cycles 280-304)

### Mapper004.cs — `NotifyA12()`

5. **VBL gap detection**
   - Tracks `lastNotifyTime` to measure gap since last notification
   - If gap > 341 (one scanline = VBL period), falling edges don't reset
     `a12LowSince` — the old value correctly reflects A12 being low during VBL

## A12 Clocking Behavior Summary

With these changes, the A12 clocking pattern per scanline is:

| Config | Valid A12 clocks per scanline | Position |
|--------|------------------------------|----------|
| $08 (Sp=$1000) | 1 | cx=263 (sprite CHR) |
| $10 (BG=$1000) | 1 (visible) + 1 (prefetch) | cx=7 + cx=327 |

For $10, the cx=7 clock (first BG CHR) passes the filter because A12 was low
for 68+ cycles (sprite section). Intra-tile BG edges (4-cycle gaps) are filtered.
The cx=327 clock (BG prefetch CHR) also passes (68-cycle gap from sprite section).

Consecutive scanline cx=7 edges have only 11-cycle A12=0 gaps (from garbage NT
at cx=337 to cx=7), which are correctly filtered by the 16-cycle threshold.

## Verification
- All 10 MMC3 tests PASS (no regressions)
- Full test suite: 156 PASS / 18 FAIL / 174 TOTAL
