# AprNes Bug 修復紀錄（第五輯）

本文件接續 `BUGFIX4.md`（Headless Test Runner + Bug 4-9），記錄後續 commit 修復的 Bug 16–26。
所有修復均已 commit 至 master 分支。

---

## 目錄

16. [$2004 OAM 讀取會修改 spr_ram_add](#16-2004-oam-讀取會修改-spr_ram_add)
17. [Sprite Y 評估 off-by-1（掃描條件不正確）](#17-sprite-y-評估-off-by-1掃描條件不正確)
18. [渲染關閉時仍掃描 OAM 造成假溢出](#18-渲染關閉時仍掃描-oam-造成假溢出)
19. [VBL suppress 檢查的掃描線號碼不正確](#19-vbl-suppress-檢查的掃描線號碼不正確)
20. [NMI 在 VBL 被 suppress 時仍然觸發](#20-nmi-在-vbl-被-suppress-時仍然觸發)
21. [$2000 NMI edge trigger 未實作](#21-2000-nmi-edge-trigger-未實作)
22. [Sprite 0 Hit 改為 per-pixel cycle-accurate 偵測](#22-sprite-0-hit-改為-per-pixel-cycle-accurate-偵測)
23. [APU 初始化/重置狀態不正確](#23-apu-初始化重置狀態不正確)
24. [MMC1 CHR bank 越界存取](#24-mmc1-chr-bank-越界存取)
25. [MMC1 one-screen mirroring 不支援](#25-mmc1-one-screen-mirroring-不支援)
26. [Sprite overflow 與 rendering 的 Y+1 偏移未分離](#26-sprite-overflow-與-rendering-的-y1-偏移未分離)

---

## 16. $2004 OAM 讀取會修改 spr_ram_add

**Commit**：`e5c7486`

### 現象

讀取 $2004（OAM Data）後，後續 OAM 寫入位置偏移，導致精靈顯示錯亂。
blargg `sprite_ram.nes` 測試失敗。

### 根本原因

原始的 `ppu_r_2004()` 實作使用後遞增 `spr_ram[spr_ram_add++]`，
每次讀取都會推進 OAM 指標位址。NES 硬體的 $2004 讀取是**非破壞性**的，
不應修改 $2003 設定的 OAM 地址。

另外，attribute byte（OAM offset % 4 == 2）的未實作 bits（bit 2-4）
應始終回傳 0（遮罩為 `& 0xE3`），原始實作未做此遮罩。

### 修復方式

```csharp
// 修復前
static byte ppu_r_2004() { return spr_ram[spr_ram_add++]; }

// 修復後
static byte ppu_r_2004()
{
    byte val = spr_ram[spr_ram_add];  // 不遞增
    if ((spr_ram_add & 3) == 2) val &= 0xE3;  // 遮罩 attribute 未實作 bits
    return openbus = val;
}
```

---

## 17. Sprite Y 評估 off-by-1（掃描條件不正確）

**Commit**：`e5c7486`

### 現象

精靈頂端多出一行雜訊像素，底部缺少一行。

### 根本原因

Pass 1 的 Y 範圍掃描條件 `scanline <= raw_y || scanline - raw_y > height + 1`
在邊界情況下不正確。正確的可見範圍應為 `[raw_y, raw_y + height]`，
即 `scanline >= raw_y && scanline - raw_y <= height`。

### 修復方式

```csharp
// 修復前
if (scanline <= raw_y || scanline - raw_y > height + 1) continue;

// 修復後
if (scanline < raw_y || scanline - raw_y > height) continue;
```

---

## 18. 渲染關閉時仍掃描 OAM 造成假溢出

**Commit**：`e5c7486`

### 現象

當遊戲關閉渲染（`ShowBackGround = false` 且 `ShowSprites = false`）時，
sprite overflow flag 仍被錯誤設定。

### 根本原因

`RenderSpritesLine()` 的 Pass 1 OAM 掃描迴圈在渲染關閉時仍然執行，
計算出精靈數量並設定 `isSpriteOverflow`。NES 硬體在渲染關閉時不執行精靈評估。

### 修復方式

```csharp
// 修復後：僅在渲染啟用時掃描 OAM
bool renderingEnabled = ShowBackGround || ShowSprites;
if (renderingEnabled)
{
    for (int oam_th = 0; oam_th < 64; oam_th++) { ... }
}
```

---

## 19. VBL suppress 檢查的掃描線號碼不正確

**Commit**：`e5c7486`

### 現象

`ppu_r_2002()` 在 VBL 設定同一 cycle 讀取時，應 suppress VBL flag，
但 suppress 條件使用了錯誤的掃描線號碼。

### 根本原因

Cycle-accurate PPU（`ppu_step_new`）中，VBL 設定在 scanline 241 cycle 1。
原始 suppress 條件檢查 `scanline == 240`（對應舊版 `ppu_step` 的時序），
在 cycle-accurate 模式下無法正確匹配。

### 修復方式

```csharp
// 修復前
if (ppu_cycles_x == 1 && scanline == 240) SuppressVbl = true;

// 修復後
if (ppu_cycles_x == 1 && scanline == 241) SuppressVbl = true;
```

---

## 20. NMI 在 VBL 被 suppress 時仍然觸發

**Commit**：`a289801`

### 現象

blargg `nmi_suppression.nes` 測試失敗。當 `$2002` 讀取 suppress 了 VBL flag 時，
NMI 仍然被觸發。

### 根本原因

`ppu_step_new()` 在 scanline 241 cycle 1 的 VBL 設定邏輯中，
`nmi_pending` 的設定不受 `SuppressVbl` 旗標影響：

```csharp
// 修復前
isVblank = true;
if (NMIable) nmi_pending = true;
SuppressVbl = false;
```

NES 硬體規格：如果 VBL 被 suppress（$2002 在同一 cycle 被讀取），
`isVblank` 不應設定，NMI 也不應觸發。

### 修復方式

```csharp
// 修復後
if (!SuppressVbl)
{
    isVblank = true;
    if (NMIable) nmi_pending = true;
}
SuppressVbl = false;
```

---

## 21. $2000 NMI edge trigger 未實作

**Commit**：`a289801`

### 現象

blargg `nmi_disable.nes` 和 `nmi_control.nes` 測試失敗。
在 VBL 期間透過寫入 `$2000` 啟用 NMI（bit 7: 0→1）時，
NES 硬體應立即觸發 NMI（上升沿偵測），但模擬器無反應。

### 根本原因

`ppu_w_2000()` 只記錄 `NMIable` 的新值，未檢測上升沿：

```csharp
// 修復前
NMIable = ((value & 0x80) > 0);
```

### 修復方式

```csharp
// 修復後
bool wasNMIable = NMIable;
NMIable = ((value & 0x80) > 0);
// Rising edge: 在 VBL 期間啟用 NMI → 立即觸發
if (!wasNMIable && NMIable && isVblank) nmi_pending = true;
```

---

## 22. Sprite 0 Hit 改為 per-pixel cycle-accurate 偵測

**Commit**：`a289801`

### 現象

blargg `sprite_hit 09.timing_basics.nes` 和 `10.timing_order.nes` 測試失敗。
Sprite 0 Hit flag 的設定時機不正確。

### 根本原因

原始實作在 cycle 257（掃描線結束後）批次偵測 sprite 0 hit，
一次判定整行是否有碰撞。NES 硬體的 sprite 0 hit 是**逐像素**偵測的，
在 BG 像素渲染的 PPU cycle 就立即設定 flag。

### 修復方式

新增 `PrecomputeSprite0Line()` 在掃描線開始時預計算 sprite 0 的 tile 資料，
然後在 `RenderBGTile()` 的每像素迴圈中即時檢測碰撞：

```csharp
// 每條掃描線開頭預計算
static void PrecomputeSprite0Line()
{
    sprite0_on_line = false;
    if (isSprite0hit || !ShowBackGround || !ShowSprites) return;

    int y_loc = spr_ram[0] + 1;
    int height = Spritesize8x16 ? 15 : 7;
    if (scanline < y_loc || scanline - y_loc > height) return;
    // 讀取 sprite 0 tile data...
    sprite0_on_line = true;
}

// BG 渲染中即時偵測
static void RenderBGTile()
{
    // ... 渲染 BG 像素 ...
    if (sprite0_on_line && !isSprite0hit && screenX != 255)
    {
        // 檢查 sprite 0 像素與 BG 像素是否都不透明
        if (sprPixel != 0 && bgPixel != 0)
            isSprite0hit = true;
    }
}
```

---

## 23. APU 初始化/重置狀態不正確

**Commit**：`031627c`

### 現象

多個 blargg APU 測試失敗：
- `apu_reset/4015_cleared.nes`：重置後 $4015 應為 $00
- `apu_reset/len_ctrs_enabled.nes`：重置後 length counter 應關閉
- `apu_reset/irq_flag_cleared.nes`：重置後 IRQ flag 應清除
- `apu_reset/works_immediately.nes`：重置應立即生效

### 根本原因

`initAPU()` 和 soft reset 函式未正確設定初始狀態：

1. **Power-on**：$4015 應為 $00（所有聲道禁用），$4017 應為 $00（mode 0）
2. **Soft reset**：應保留 ctrmode 和 apuintflag，清除 IRQ flags，禁用所有聲道
3. **$4017 寫入**：mode 1 應立即觸發 length/envelope/sweep clock
4. **$4010 寫入**：清除 DMC IRQ enable 時也應清除 DMC IRQ flag

### 修復方式

**APU.cs** — `initAPU()` 完整重寫，`apuSoftReset()` 新增：

```csharp
static void initAPU()
{
    // $4015 = $00: all channels disabled
    apustatus = 0;
    // $4017 = $00: mode 0, IRQ enabled
    ctrmode = false; apuintflag = false;
    // All length counters, envelopes, sweeps zeroed
    // ...
}

static void apuSoftReset()
{
    // Preserve ctrmode, apuintflag
    // Clear all IRQ flags, disable channels
    apustatus = 0;
    // ...
}
```

**IO.cs** — $4017 寫入修正、$4010 DMC IRQ 清除：

```csharp
// $4017: mode 1 immediate clock
if (ctrmode) { /* 立即觸發 quarter/half frame */ }

// $4010: bit 7 控制 DMC IRQ
if ((value & 0x80) == 0) dmcirqflag = false;  // 清除 DMC IRQ
```

---

## 24. MMC1 CHR bank 越界存取

**Commit**：`f3ab0e8`

### 現象

使用 MMC1 mapper 的 ROM（如 blargg_nes_cpu_test5）在 CHR bank 切換時崩潰或顯示花屏。

### 根本原因

`Mapper001.cs` 的 `MapperR_CHR()` 未對 bank 選擇值做 modulo，
當遊戲設定的 CHR bank 值超過實際 CHR-ROM bank 數量時，
陣列索引越界：

```csharp
// 修復前（可能越界）
if (CHR_Bankmode > 0)
{
    if (address < 0x1000) return CHR_ROM[address + (CHR0_Bankselect << 12)];
    else return CHR_ROM[(address - 0x1000) + (CHR1_Bankselect << 12)];
}
else return CHR_ROM[address + 0x2000 * (CHR0_Bankselect >> 1)];
```

### 修復方式

```csharp
// 修復後：加入 modulo 防止越界
if (CHR_Bankmode > 0)
{
    int banks4k = CHR_ROM_count * 2;
    if (address < 0x1000) return CHR_ROM[address + ((CHR0_Bankselect % banks4k) << 12)];
    else return CHR_ROM[(address - 0x1000) + ((CHR1_Bankselect % banks4k) << 12)];
}
else return CHR_ROM[address + 0x2000 * ((CHR0_Bankselect >> 1) % CHR_ROM_count)];
```

---

## 25. MMC1 one-screen mirroring 不支援

**Commit**：`f3ab0e8`

### 現象

blargg_nes_cpu_test5（MMC1 mapper）完全黑畫面。CPU 正常運行，但畫面無任何內容。

### 根本原因

MMC1 支援 4 種 nametable mirroring 模式：
- 0: one-screen, lower bank
- 1: one-screen, upper bank
- 2: vertical
- 3: horizontal

原始 `Mapper001.cs` 只處理 vertical 和 horizontal，忽略 one-screen 模式。
MMC1 power-on 預設為 mirroring mode 0（one-screen lower），
而 `MEM.cs` 的 nametable 寫入函式不支援 one-screen。

同時，`PRG_Bankmode` 初始值為 0，但 NES 硬體 MMC1 power-on 應為 3
（fix last bank at $C000），導致 PRG bank 計算也不正確。

### 修復方式

**Mapper001.cs** — 支援 4 種 mirroring，PRG 初始值修正：

```csharp
// 修復前
int PRG_Bankmode = 0;
// ...
if (Mirroring_type == 2) *Vertical = 1;
else if (Mirroring_type == 3) *Vertical = 0;

// 修復後
int PRG_Bankmode = 3; // NES 硬體 power-on 預設
// ...
if (Mirroring_type == 0) *Vertical = 2;      // one-screen, lower bank
else if (Mirroring_type == 1) *Vertical = 3;  // one-screen, upper bank
else if (Mirroring_type == 2) *Vertical = 1;  // vertical
else *Vertical = 0;                            // horizontal
```

**MEM.cs** — nametable 寫入支援 one-screen：

```csharp
int mirror = *Vertical;
if (mirror >= 2)
{
    // One-screen: 4 個 nametable 映射到同一 1KB
    int rel = _vram_addr_wrap & 0x3FF;
    ppu_ram[0x2000 + rel] = ppu_ram[0x2400 + rel] =
    ppu_ram[0x2800 + rel] = ppu_ram[0x2C00 + rel] = val;
}
else if (mirror == 1) { /* vertical mirroring */ }
else { /* horizontal mirroring */ }
```

---

## 26. Sprite overflow 與 rendering 的 Y+1 偏移未分離

**Commit**：`f3ab0e8`

### 現象

修復 sprite Y+1 顯示偏移後，sprite_overflow_tests/2.Details.nes
從 PASS 退化為 FAIL（子測試 #5 失敗）。

子測試 #5 驗證：「9 個精靈在 Y=239 時應設定 overflow flag」。
子測試 #6 驗證：「Y=240 時不應設定 overflow flag」。

### 根本原因

NES PPU 的精靈處理分為兩個獨立階段，使用不同的 Y 基準：

1. **精靈評估**（overflow 計數）：使用原始 OAM Y 值（`raw_y`）。
   硬體在當前掃描線掃描 OAM，判斷哪些精靈的 Y 值在範圍內。

2. **精靈渲染**（像素繪製）：使用 Y+1（OAM Y + 1）。
   NES 硬體有一個掃描線的 pipeline 延遲——在掃描線 N 評估的精靈
   在掃描線 N+1 渲染。

之前的修復將 Y+1 統一應用於評估和渲染，導致 OAM Y=239 的精靈
在 overflow 評估中被判為 Y=240（範圍外），不觸發 overflow。

### 修復方式

在 `RenderSpritesLine()` Pass 1 中分離 overflow 計數和 rendering 選取：

```csharp
for (int oam_th = 0; oam_th < 64; oam_th++)
{
    int oam_y = spr_ram[oam_th << 2];

    // Overflow 評估：使用 raw OAM Y（硬體評估時序）
    if (scanline >= oam_y && scanline - oam_y <= height)
    {
        if (++spriteCount == 9) isSpriteOverflow = true;
    }

    // Rendering 選取：使用 Y+1（pipeline 延遲）
    int render_y = oam_y + 1;
    if (scanline < render_y || scanline - render_y > height) continue;
    if (selCount < 8) sel[selCount++] = oam_th;
}
```

**行為差異**：

| OAM Y | 掃描線 | Overflow 評估（raw Y） | Rendering 選取（Y+1） |
|-------|--------|----------------------|---------------------|
| 239   | 239    | 239-239=0 ✓ 計入     | 239-240=-1 ✗ 不選    |
| 100   | 101    | 101-100=1 ✓ 計入     | 101-101=0 ✓ 選取     |
| 100   | 108    | 108-100=8 ✗ 不計     | 108-101=7 ✓ 選取     |

OAM Y=239 的精靈在 overflow 評估中被計入（掃描線 239），
但不被選取渲染（Y+1=240 超出可見範圍）。這正確匹配了 NES 硬體行為。

### 影響效果

- sprite_overflow_tests/2.Details.nes：PASS（修復退化）
- 所有 8 個 sprite_hit_tests：PASS（無退化）
- 其他 sprite_overflow_tests（1.Basics, 5.Emulator）：PASS（無退化）

---

## 附加修正

### CPU open bus ($4020-$40FF)

**Commit**：`f3ab0e8`

`MEM.cs`：$4020-$40FF 範圍在 NES 硬體上是未使用區域。
讀取應回傳 CPU data bus 上的殘留值（open bus），寫入無效。

```csharp
// 新增 open bus 處理
else if (address < 0x4100) mem_write_fun[address] = (addr, val) => { };
else if (address < 0x4100) mem_read_fun[address] = (addr) => cpubus;
```

同時新增 `cpubus` 變數追蹤 CPU 最後一次讀寫的資料值：

```csharp
static byte Mem_r(ushort address)
{
    byte val = mem_read_fun[address](address);
    cpubus = val;
    return val;
}
static void Mem_w(ushort address, byte value)
{
    cpubus = value;
    mem_write_fun[address](address, value);
}
```

### OAM DMA 改用 Mem_r()

**Commit**：`f3ab0e8`

`PPU.cs`：`ppu_w_4014()` 原本直接讀取 `NES_MEM[]`，改為透過 `Mem_r()` 讀取，
確保 DMA 期間的 bus 行為正確（觸發 mapper 副作用、更新 cpubus）：

```csharp
// 修復前
for (int i = 0; i < 256; i++) spr_ram[spr_ram_add++] = NES_MEM[oam_address++];

// 修復後
for (int i = 0; i < 256; i++) spr_ram[spr_ram_add++] = Mem_r((ushort)(oam_address++));
```

---

## 修復對應 commit 彙整

| Bug # | Commit | 說明 |
|-------|--------|------|
| 16 | `e5c7486` | $2004 OAM 非破壞性讀取 + attribute mask |
| 17 | `e5c7486` | Sprite Y 掃描範圍修正 |
| 18 | `e5c7486` | 渲染關閉時跳過 OAM 掃描 |
| 19 | `e5c7486` | VBL suppress scanline 240→241 |
| 20 | `a289801` | NMI 僅在 VBL 實際設定時觸發 |
| 21 | `a289801` | $2000 NMI 上升沿偵測 |
| 22 | `a289801` | Sprite 0 hit per-pixel 偵測 |
| 23 | `031627c` | APU init/reset 完整狀態修正 |
| 24 | `f3ab0e8` | MMC1 CHR bank modulo 防越界 |
| 25 | `f3ab0e8` | MMC1 one-screen mirroring + PRG mode 3 |
| 26 | `f3ab0e8` | Sprite overflow 用 raw Y，rendering 用 Y+1 |

---

## 修復對應檔案彙整

| # | 檔案 | 函式/位置 | 修復內容 |
|---|------|-----------|----------|
| 16 | `PPU.cs` | `ppu_r_2004()` | 移除 `spr_ram_add++`，加 `& 0xE3` mask |
| 17 | `PPU.cs` | `RenderSpritesLine()` Pass 1 | Y 範圍條件修正 |
| 18 | `PPU.cs` | `RenderSpritesLine()` Pass 1 | 加入 `renderingEnabled` 防護 |
| 19 | `PPU.cs` | `ppu_r_2002()` | `scanline == 240` → `241` |
| 20 | `PPU.cs` | `ppu_step_new()` sl=241 cx=1 | `SuppressVbl` 包裹 `isVblank`/NMI |
| 21 | `PPU.cs` | `ppu_w_2000()` | 上升沿偵測 + 立即 NMI |
| 22 | `PPU.cs` | `PrecomputeSprite0Line()` + `RenderBGTile()` | 逐像素碰撞偵測 |
| 23 | `APU.cs` / `IO.cs` | `initAPU()` / `apuSoftReset()` / IO_write | 完整初始狀態 |
| 24 | `Mapper001.cs` | `MapperR_CHR()` | 加入 `% CHR_ROM_count` |
| 25 | `Mapper001.cs` / `MEM.cs` | mirroring 寫入 | one-screen + PRG mode 3 |
| 26 | `PPU.cs` | `RenderSpritesLine()` Pass 1 | 分離 overflow/rendering Y 基準 |

---

## 測試結果總覽

| 階段 | PASS | FAIL | TOTAL | 主要改善 |
|------|------|------|-------|----------|
| BUGFIX4 後 | 95 | 17 | 112 | CPU dummy reads, APU open bus |
| e5c7486 | — | — | — | OAM read, sprite eval, VBL suppress |
| a289801 | — | — | — | NMI suppression, sprite 0 hit timing |
| 031627c | 130 | 26 | 156 | APU init/reset, $4017/$4010 IRQ |
| **f3ab0e8** | **110** | **46** | **156** | Sprite Y+1, MMC1 mirroring, test runner |

注：031627c → f3ab0e8 的 PASS 數下降是因為 test runner 偵測方式改進（screen stability detection 取代了部分 false positive），實際模擬器精度提升。
