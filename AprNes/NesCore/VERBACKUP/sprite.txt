     public void RenderSpritesLine()
        {

            int offset = 0;
            if (SpPatternTableAddr == 0x1000)
                offset = 256;

            int spriteCount = 0;

            int line_t, loc_t;
            byte pixel;

            for (int oam_th = 63; oam_th >= 0; oam_th--)
            {
                int y_loc = spr_ram[oam_th * 4] + 1;

                if (!Spritesize8x16)
                {
                    if (scanline >= y_loc && scanline <= (y_loc + 7))
                    {

                        byte tile_th = spr_ram[oam_th * 4 + 1];
                        byte sprite_attr = spr_ram[oam_th * 4 + 2];
                        byte x_loc = spr_ram[oam_th * 4 + 3];

                        int spr_color = sprite_attr & 3;

                        bool priority = ((sprite_attr & 0x20) > 0) ? true : false;
                        bool flip_x = ((sprite_attr & 0x40) > 0) ? true : false;
                        bool flip_y = ((sprite_attr & 0x80) > 0) ? true : false;

                        int pal_offset = 0x3f10 + spr_color * 4;

                        int line;
                        int tile_th_t;

                        tile_th_t = tile_th + offset;
                        line = scanline - y_loc;

                        if (flip_y) line_t = (7 - line); else line_t = line;

                        for (int loc = 0; loc < 8; loc++)
                        {

                            if ((x_loc + loc) > 255)
                                continue;


                            if (flip_x) loc_t = (7 - loc); else loc_t = loc;
                            pixel = pre_Dec_tiles[64 * (tile_th + offset) + loc_t + line_t * 8];

                            if (oam_th == 0 && !isSprite0hit && pixel != 0 && Buffer_BG_array[x_loc + loc][scanline] != 0) isSprite0hit = true;
                            if ((pixel != 0 && !priority) || (pixel != 0 && priority && Buffer_BG_array[x_loc + loc][scanline] == 0))
                                Buffer_Screen_array[x_loc + loc][scanline] = NesColors[ppu_ram[pal_offset + pixel]];

                        }
                        spriteCount++;
                        if (spriteCount == 9)
                            isSpriteOverflow = true;
                    }
                }
                else
                {
                    if (scanline >= y_loc && scanline <= (y_loc + 15))
                    {

                        byte byte0 = spr_ram[oam_th * 4 + 1];
                        byte tile_th = (byte)((byte0 & 0xfe) >> 0);

                        if ((byte0 & 1) > 0)
                            offset = 256;
                        else
                            offset = 0;

                        byte sprite_attr = spr_ram[oam_th * 4 + 2];
                        byte x_loc = spr_ram[oam_th * 4 + 3];

                        int spr_color = sprite_attr & 3;

                        bool priority = ((sprite_attr & 0x20) > 0) ? true : false;
                        bool flip_x = ((sprite_attr & 0x40) > 0) ? true : false;
                        bool flip_y = ((sprite_attr & 0x80) > 0) ? true : false;

                        int pal_offset = 0x3f10 + spr_color * 4;


                        int line;
                        int tile_th_t;
                        if (scanline >= y_loc && scanline <= (y_loc + 7))
                        {
                            tile_th_t = tile_th + offset;
                            line = scanline - y_loc;
                        }
                        else
                        {
                            tile_th_t = tile_th + offset + 1;
                            line = (scanline - y_loc) - 8;
                        }

                        if (flip_y) line_t = (7 - line); else line_t = line;
                        for (int loc = 0; loc < 8; loc++)
                        {
                            if ((x_loc + loc) > 255) continue;

                            if (flip_x) loc_t = (7 - loc); else loc_t = loc;
                            pixel = pre_Dec_tiles[64 * tile_th_t + loc_t + line_t * 8];
                            if (oam_th == 0 && !isSprite0hit && pixel != 0 && Buffer_BG_array[x_loc + loc][scanline] != 0) isSprite0hit = true;
                            if ((pixel != 0 && !priority) || (pixel != 0 && priority && Buffer_BG_array[x_loc + loc][scanline] == 0))
                                Buffer_Screen_array[x_loc + loc][scanline] = NesColors[ppu_ram[pal_offset + pixel]];
                        }
                        spriteCount++;
                        if (spriteCount == 9)
                            isSpriteOverflow = true;
                    }
                }
            }
        }